# 연산자 오버로딩과 기타 관례
자바에서는 일반적으로 언어 기능을 사용할 떄 타입을 사용한다.
예를 들어 for ... in 루프에서는 java.lang.Iterable을 구현한 객체를 사용할 수 있고,   
try-with-resource 문은 java.lang.AutoCloseable을 구현한 객체를 사용할 수 있다.

코틀린은 타입이 아니라 함수의 이름을 관례로 적용한다. 예를 들어 plus라는 이름의 함수를 정의하면 + 연산자를 오버로딩할 수 있다.

# 산술 연산자의 오버로딩

```kotlin
data class Point(val x: Int, val y: Int){
    // 산술 연산 + 에 대한 관례 함수
    operator fun plus(other: Point):Point{
        return Point(x + other.x, y + other.y)
    }
}
```
operator 키워드를 추가하여 관례에 따라 plus가 +를 대신하도록 구현할 수 있다. 
또한 확장함수를 통해서도 연산자를 정의할 수도 있다.

```kotlin
operator fun Point.plus(other: Point):Point{
    return Point(x + other.x, y + other.y)
}
```

코틀린에서는 프로그래머가 직접 연산자를 만들어 사용할 수 없고 언어에서 미리 정해둔 연선자만 오버로딩할 수 있다.
그 연산자와 매핑되는 이름은 관례에 따라 미리 지정되어 있다.

> a * b : times   
> a / b : div   
> a % b : mod(1.1이상은 rem)
> a + b : plus   
> a - b : minus    

직접 정의한 함수로 연산자를 오버로딩하더라도 연산자의 우선순위는 그대로 적용된다.
연산자를 정의할 때 두 피연산자가 항상 같은 타입일 필요는 없다.
ex) string + Int

## 연산자 오버로딩의 특징
1. 함수의 주체는 연산자의 좌변에 있는 피연산자이다.       
따라서 Point * 1.5 는 Point에 정의해야 하고, 1.5 * Point는 Double에 정의해야 한다.
2. 연산자 함수의 반환 타입이 반드시 두 피연산자 중 하나와 일치할 필요는 없다.
3. 비트 연산자는 재정의하지 않는다.
코틀린에서는 비트연산자를 사용하지 않고 중위 연산자 표기법을 지원하는 일반 함수를 사용한다.
```kotlin
val p = 5 and 3
```

## 복합 대입 연산자 오버로딩
plus와 같은 연산자를 오버로딩하면 코틀린은 + 뿐만아니라 +=도 자동으로 함께 ㅣㅈ원한다.
```kotlin
point += Point(3,4)
point = point + Point(3,4)
// 두 식은 서로 동일하다
```

경우에 따라 += 연산이 객체에 대한 참조를 새롭게 바꾸기 보다 원래 객체의 내부 상태를 변경하고 싶을 때가 있다.   
예를 들어 변경 가능한 컬렉션에 원소를 추가하는 일이 있다.

반한 타입이 Unit인 plusAssign 함수를 정의하면 코틀린은 += 연산자에 이 함수를 사용한다.   
이는 다른 복합 대입연산자도 마찬가지이다.   

이론적으로 코드에 있는 +=를 plus(자동적용)와 plusAssign을 양쪽으로 컴파일 할 수 있다.   
어떤 클래스가 이 두함수를 모두 정의하여 모두 +=에 사용할 수 있으면 충돌이 발생한다.   
 
### 컬렉션에서의 적용
#### 읽기 전용 컬렉션
1. +, - 는 항상 새로운 컬렉션을 새로 만든다.
2. += 와 -=는 변경을 적용한 컬렉션을 새로 만든다.
(새로 생성된 컬렉션을 대입해야 하므로 참조를 바꾸기 위해 var 사용해야 한다)

#### 변경 가능 컬렉션
1. +, - 는 항상 새로운 컬렉션을 새로 만든다. 
2. +=, -=는 컬렉션 자체에 원소를 추가 / 제거한다.

## 단항 연산자
단항 연산자 역시 이항 연산자와 동일하게 동작한다 

> +a : unaryPlus      
> -a : unaryMinus   
> !a : not   
> ++a, a++ : inc      
> --a, a-- : dec    

```kotlin
operator fun unaryMinus() : Point{
    return Point(-x, -y)
}
```