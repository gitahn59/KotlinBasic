# 인라인 함수 : 람다의 부가 비용 없애기

코틀린에서 람다를 함수 인자로 너기는 구문은 if나 for와 같은 일반 문장과 비슷하다.
with와 apply 함수가 그런 예시다. 
5장에서 코틀린이 람다를 무명 클래스로 컴파일하지만 매번 인스턴스를 생성하지는 않는다고 배웠다.
하지만 람다가 변수를 포획하면 람다가 생성되는 시점마다 새로운 인스턴스가 생긴다.
이런 경우 실행 시점에 무명 클래스 생성에 따라 부가 비용이 발생한다.

따라서 람다를 사용하는 구현은 똑같은 작업을 수행하는 일반 함수보다 비효율적이다.
이러한 점을 해결하기 위해 inline 변경자를 사용한다.
inline 변경자를 사용하면 컴파일러는 함수를 호출하는 모든 문장을
함수 본문에 해당하는 바이트코드로 바꾼다.

## 2.1 인라인이 작동하는 방식
어떤 함수를 inline으로 선언하면 그 함수의 본문이 인라인이된다.
함수를 호출하는 코드 대신 함수 본문을 직접 가져다 사용한 코드로 컴파일한다는 뜻이다.   

이러한 함수에 람다를 전달하면 람다의 본문도 함께 인라이닝된다.
람다의 본문에 의해 만들어지는 바이트코드는 그 람다를 호출하는 코드 정의의 
일부분으로 간주되기 때문이다.

> 람다를 변수에 저장하고 전달하는 경우 람다 본문은 인라이닝되지 않는다.

## 2.2 인라인 함수의 한계
인라이닝의 방식에 따라 람다를 사용하는 모든 고차 함수를 인라이닝할 수는 없다.
함수가 인라이닝될 떄 그 함수에 인자로 전달된 람다 식의 분문은 결과 코드에 들어갈 수 있다.
하지만 람다가 본문에 직접 펼쳐지기 때문에 파라미터로 전달받은 람다를 본문에 사용하는 방식이
한정된다. 

함수 본문에서 파라미터로 받은 람다를 호출한다면 그 호출은 쉽게 람다 본문으로 바꿀 수 있다. 
하지만 파라미터로 전달된 람다A를 다시 다른 함수에 전달하거나 하여 람다 A에 대한 참조를 발생시키면(단순 호출x)
컴파일러는 "Illegal usage of inline-parameter"라는 메시지와 함께 인라이닝을 금지시킨다.   

> 파라미터로 전달 받은 람다는 다시 다른 함수로 전달할 수 없다. 
> 이를 해결하려면 inline을 지우거나 그 람다만 noninline 키워드를 붙여 참조 자체를 받아야 한다.

```kotlin
// noinline 키워드가 없으면 컴파일러 에러가 발생한다.
inline fun newMethod(a: Int, func: () -> Unit, noinline func2: () -> Unit) {
    func()
    someMethod(10, func2)
}

fun someMethod(a: Int, func: () -> Unit):Int {
    func()
    return 2*a
}
```

```kotlin
inline fun newMethod(a: Int, func: () -> Unit, func2: () -> Unit) {
    func()
    someMethod(10, func2)
}
inline fun someMethod(a: Int, func: () -> Unit):Int {
    func()
    return 2*a
}
```
> 하지만 아예 전달할 대상이 되는 함수마저 inline으로 바꾸면 람다를 다시 전달할 수 있다.    
> 결과적으로 코드가 하나가 되어 참조를 전달할 필요가 없기 때문이다.   

시퀸스에 대해 동작하는 메소드 중에서 람다를 받아 모든 시퀀스 원소에 람다를 적용한
새 시퀀스를 반환하는 함수가 만다. 그런 함수는 인자로 받은 람다를
시퀀스 객체 생성자의 인자로 넘기곤 한다.

```kotlin
fun <T,R> sequence<T>.map(transform : (T) -> R) : Sequence<R> {
    return TransformingSequence(this, transform)
} 
```
이 map 함수는 transform 파라미터로 전달받은 함수 값을 호출하지 않고 TransformingSequence라는 
클래스의 생성자에게 그 함수 값을 전달한다.

이런 기능을 지원하려면 map에 전달하는 transform 인자를 인라이닝 하지 않은 함수 표현으로
만들 수밖에 없다. 이 경우 함수 인터페이스를 구현하는 무명 클래스 인스턴스로 만들어야만 한다.

둘 이상의 람다를 인자로 받는 함수에서 일부 람다만 인라이닝하고 싶을 때도 있다.
예를 들어 어떤 람다에 너무 많은 코드가 들어가거나 어떤 람다는 인라이닝을 하면 안되는 코드가
들어갈 가능성이 있다면 그런 람다를 인라이닝하면 안 된다.

이런 식으로 인라이닝하면 안 되는 람다를 파라미터로 받는다면 noinline 변경자를 
파라미터 앞에 붙여 인라이닝을 금지할 수 있다.

## 2.3 컬렉션 연산 인라이닝
컬렉션에 대해 작용하는 코틀린 표준 라이브러리의 성능을 보자. 코틀린 표준 라이브러리의
컬렉션 함수는 대부분 람다를 인자로 받는다. 표준 라이브러리 함수를 사용하지 않고
직접 이런 연산을 구현한다면 더 효율적이지 않을까?

코틀린의 filter 함수는 인라인 함수다. 따라서 filter 함수의 바이트 코드는
그 함수에 전달된 람다 본문의 바이트코드와 함께 filter를 호출한 위치에 들어간다.
따라서 성능은 비슷하다.

그렇다면 여러 함수를 연쇄해서 사용하면 어떨까?
처리할 원소가 많아지면 중간 리스트를 사용하면 부가 비용이 증가한다.
asSequence를 통해 리스트 대신 시퀀스를 사용하면 중간 리스트로 인한 부가비용이 감소한다.
하지만 시퀀스는 람다를 인라인하지 않는다. 
시퀀스 연산에서는 람다가 인라이닝되지 않기 떄문에 크기가 작은 컬렉션은 오히려 
일반 컬렉션 연산이 성능이 더 좋을 수 있다.

시퀀스를 통해 성능을 향상시키려면 어느정도 크기가 큰 경우뿐이다.

## 2.4 함수를 인라인으로 선언해야 하는 경우
inline 키워드를 사용해도 람다를 인자로 받는 함수만 성능이 높아질 가능성이 높다.
JVM이 이미 강력하게 인라이닝을 지원하기 때문이다.
JVM은 코드 실행을 분석해서 가장 이익이 되는 방향으로 호출을 인라이닝하다.
이런 과정은 바이트 코드를 실제 기계어 코드로 번역하는 과정(JIT)에서 일어난다.

이런 JVM 최적화를 활용한다면 바이트코드에서는 각 함수 구현이 정확히 한 번만 있으면 되고,
그 함수를 호출하는 부분에서 따로 함수 코드를 중복할 필요가 없다.

반면 코틀린 인라인 함수는 바이트 코드에서 각 함수 호출 지점을 함수 본문으로 대치하기 때문에
코드 중복이 생긴다. 함수를 직접 호출하는 경우가 오히려 스택 트레이스가 더 깔끔해진다.

람다를 인자로 받는 함수를 인라이닝하면 이익이 더 많다.
1. 인라이닝을 통해 부가 비용을 줄일 수 있다. => 객체 생성 감소
2. 현재의 JVM은 함수 호출과 람다를 인라이닝해 줄 정도로 똑똑하지는 않다.
3. 인라이닝을 사용하면 일반 람다에서 사용할 수없는 기능을 사용할 수 있다.

## 2.5 자원 관리를 위해 인라인된 람다 사용
람다로 중복을 없앨 수 있는 일반적 패턴 중 한 가지는 작업 전에
자원을 획득하고 자원을 해제하는 자원 관리 과정이다.

자원은 파일 / 락 / 트랜잭션 등 여러 다른 대상을 가리킬 수 있다.

보통 자원 관리 패턴을 만들 때 사용하는 방법은 try / finally 문을 사용한다.
코틀린 라이브러리는 withLock lock에 대해 자원 취득과 반환을 대신 실행해준다.
그저 사용할 코드를 람다로 전달해주면 된다.

코틀린에서는 자바의 try-with-resource와 같은 기능을 use 함수로 제공한다.
use 함수는 닫을 수 있는(Closable) 자원에 대한 확장 함수이며 람다를 인자로 받는다.
use는 람다를 호출한 다음 자원을 닫아준다.
이때 람다가 정상 종료한 경우나 예외가 발생한 경우에나 자원을 확실히 닫아준다.
물론 use 함수도 인라인 함수로 구현되어있다.

람다의 본문 안에서 사용한 return은 넌로컬 return이다.
이 return 문은 람다가 아니라 람다를 사용한 함수를 끝내면서 값을 반환한다.


 