# 2. 뻔하지 않은 생성자와 프로퍼티를 갖는 클래스 선언

코틀린에서는 생성자를 여러개 선언할 수 있으며 주 생성자와 부 생성자를 구분한다.

## 2.1 클래스 초기화 : 주 생성자와 초기화 블록

```kotlin
class User(val nickname : String)
```
주 생성자는 생성자 파라미터를 지정하는 동시에 그 파라미터를 초기화한다.   
이러한 선언은 다음과 동치이다.   

```kotlin
// 리스트1
class User constructor(name : Stirng) {
    val nickname : String
    init{
        nickname = name
    }
}
```

* constructor 키워드는 주, 부 생성자를 선언할 때 사용
* init 키워드는 초기화 블록으로 사용

> 초기화 블록에는 초기화 코드가 들어간다
> 초기화 블록은 주 생성자를 초기화할 때 사용된다.
> 주 생성자는 제한적이기 때문에 초기화 블록을 사용해서 복잡한 과정을 처리할 수 있다.   

프로퍼티를 초기화하는 코드를 선언에 포함시킬 수 있을 정도로 간단하다면(단순 대입) 초기화 블록을 사용할 필요가 없다.
주 생성자 앞에 별다른 가시성 변경자가 없다면 constructor 키워드는 생략 할 수 있다.

```kotlin
// 리스트2
class User(_nickname : String){
    val nickname = _nickname
}
```

프로퍼티를 초기화하는 식이나, 초기화 블록 안에서만 주 생성자의 파라미터를 참조 할 수 있다.      
리스트 1에서 name 은 초기화 블록 안에서 접근했다.   
리스트 2에서 _nickname 은 프로퍼티를 초기화하는 식에서 접근했다.   

> 모든 생성자 파라미터에 디폴트 값을 지정하면    
> 컴파일러는 자동으로 파라미터 없는 생성자를 생성한다.   
> 이러한 기법은 프레임워크와의 통합을 도와준다.   

클래스에 수퍼 클래스가 있다면    
주 생성자에서는 기반 클래스의 생성자를 호출해야 한다.
이러한 규칙들로 인해 기반 클래스의 이름 뒤에는 이를 초기화하는 괄호가 반드시 들어간다.
인터페이스는 생성과정이 없으므로 괄호가 없어 클래스와 구분할 수 있다.

어떤 클래스의 생성을 막고 싶다면 생성자 앞에 private 가시성 제어자를 추가한다. 
그러면 생성자를 호출할 수 없으며, 외부에서 인스턴스화 할 수없다.   
이 경우 동반 객체를 사용하여 인스턴스화를 수행한다.   

## 2.2 부 생성자 : 상위 클래스를 다른 방식으로 초기화

> tip 
> 인자에 대한 디폴트 값을 제공하기 위해 부 생성자를 여러개 만들지 말라.   
> 파라미터의 디폴트 값을 생성자 시그니처에 명시하는 것이 좋다.   

부 생성자는 super() 를 사용해서 자신의 수퍼 클래스의 생성자를 호출해야 한다.   
또한 자바와 마찬가지로 this() 를 사용하면 자신의 다른 생성자를 호출할 수 있다.

> 클래스에 주 생성자가 없다면    
> 모든 부 생성자는 반드시 상위 클래스의 생성자를 호출하거나      
> 다른 생성자에게 생성을 위임해야 한다.    
> (다른 생성자에는 수퍼 클래스의 생성자를 호출하는 생성자가 있어야 한다)   

부 생성자가 필요한 주된 이유는 자바와의 상호 운용성이다.

그 외에는 부생성자가 필요한 경우는 
인스턴스를 생성할 때 파라미터 목록이 다른 생성 방법이 여러개 존재하는 경우일 것이다.

## 2.3 인터페이스에 선언된 프로퍼티 구현

코틀린의 인터페이스는 추상 프로퍼티 선언을 넣을 수 있다.
```kotlin
interface User {
    val nickname : String
}
```

User 인터페이스를 구현하는 클래스가 nickname의 값을 얻을 수 있는 방법(게터)을 제공해야 한다는 뜻이다.

인터페이스에 있는 프로퍼티 선언에는 뒷받침 필드나 게터 정보가 들어있지 않다.
인터페이스는 아무 상태도 포함할 수 없으므로 
상태를 저장하고 싶다면 인터페이스를 구현한 하위 클래스에서 상태 저장을 위한 프로퍼티를 만들어야 한다.   

### 인터페이스를 구현하는 방법
```kotlin
interface User {
    val nickname : String
}

class PrivateUser(override val nickname: String): User // 주 생성자를 통한 자동 생성 프로퍼티

class SubscribingUser(val email: String): User {
    override val nickname: String
        get() = email.substringBefore('@') // 커스텀 게터
}

class FackbookUser(val accountId: Int): User { 
    override val nickname = getFacebookName(accountId)
}       
```

* PrivateUser는 주 생성자 안에 프로퍼티를 직접 선언하는 간단 구문을 사용한다.   
    User의 추상 프로퍼티를 구현하므로 override를 표기해야 한다.
* SubscribingUser는 커스텀 게터를 사용해 nickname 프로퍼티를 설정한다.   
    뒷받침 필드에 값을 저장하지 않고 매번 이메일 주소에서 별명을 계산한다.
* FacebookUser에서는 초기화를 통해 뒷바침 필드에 nickname 값을 저장해 둔다.

2 의 경우 호출시마다 매번 계산하는 커스텀 게터를 활용하고    
3 은 객체 초기화 시 계산한 데이터를 뒷바침 필드에서 참조만 한다.

> 인터페이스에는 추상 프로퍼티뿐 아니라 게터와 세터가 있는 프로퍼티를 선언할 수도 있다.
> 물론 이 경우 게터와 세터는 뒷받침 필드를 참조 할 수 없다.
> 뒷받침 필드가 있다면 상태를 추가하는 셈이며 인터페이스는 상태를 관리하지 않는다.

## 2.4 게터와 세터에서 뒷받침하는 필드에 접근

값을 저장하는 동시에 로직을 실행하고 싶다면 접근자 안에서 뒷바침 필드에 접근할 수 있어야 한다.
저장된 값의 변경 이력을 로그에 남기는 경우를 생각해보자.
변경 가능한 프로퍼티를 정의해야 하며 프로퍼티 값을 바꿀 때마다 로그를 남겨야 한다.

```kotlin
class user(val name: String){
    var address : String = "unspecified"
        set(value: String){
            println("기록합니다")
            field = value
        }
}
```

접근자에서는 field 라는 특별한 식별자를 통해 뒷받침 필드에 접근할 수 있다.   
게터에서는 field 값을 읽을 수만 있고, 세터에서는 field 값을 읽거나 변경할 수 있다.

사실 클라이언트 입장에서는 프로퍼티를 읽는 방법이나 쓰는 방법은 뒷받침 필드가 존재하는지와는 관계가 없다.   
컴파일러는 디폴트 접근자 구현을 사용하건, 커스텀 구현을 사용하건 
게터나 세터에서 field 를 사용하는 프로퍼티에 대해 뒷받침 필드를 생성한다.

> 게터나 세터에서 field 를 사용하지 않는 구현을 정의한다면 뒷받침 필드는 존재하지 않는다.   
> val 인 경우 게터에만 field 가 없으면 된다. (어짜피 게터만 사용할 수 있다)
> var 인 경우 게터나 세터 모두에 field 가 없어야 한다.

## 2.5 접근자의 가시성 변경

기본적으로 접근자의 가시성은 기본적으로 프로퍼티의 가시성과 같다. 
물론 원한다면 게터나 세터 앞에 가시성 변경자를 추가해 새로운 다른 가시성을 부여할 수 있다.

```kotlin
class LengthCounter {
    var counter : Int = 0
        private set
    
    fun addWord(word : Stirng){
        counter+=word.length
    }
}
```

단어의 길이가 누적되므로 파라미터는 var을 사용한다. 하지만 이는 외부에서 함부로
변경하면 안돼므로 set에 private를 부여한다.
그러면 내부적으로만 프로퍼티의 값을 바꿀 수 있다.
