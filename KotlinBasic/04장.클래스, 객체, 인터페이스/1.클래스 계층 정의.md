# 4장
- 클래스와 인터페이스
- 뻔하지 않은 생성자와 프로퍼티
- 데이터 클래스
- 클래스 위임
- object 키워드

# 1 클래스 계층 정의
1. 코틀린에서 클래스 계층(클래스 밖은 최상위 계층)을 정의하는 방식과 자바 방식을 비교한다.
2. 코틀린의 가시성과 접근 변경자에 대해 알아본다. 코틀린 가시성 접근 변경자는 자바와 비슷하지만 default는 서로 다르다.
3. 코틀린에서 새로 생긴 sealed 변경자에 대해 설명한다. sealed 는 클래스 상속을 제한한다.

## 1.1 코틀린 인터페이스
코틀린의 인터페이스는 자바8의 인터페이스와 비슷하다.   
인터페이스 안에서 추상 메소드뿐 아니라 디폴트 메소드도 정의할 수 있다.   
다만 인터페이스에는 아무런 상태(필드)도 들어갈 수 없다.   

```kotlin
interface Clickable{
    fun click()
}
```

click 이라는 추상 메소드가 있는 인터페이스를 정의한다.    
이 인터페이스를 구현하는 비추상 클래스는 click 에 대한 구현을 제공해야 한다.

```kotlin
class Button : Click{
    override fun click() = println("I was clicked")
}
```

코틀린에서는 인터페이스나 클래스를 상속할 때 인터페이스와 클래스 이름을 적어 표기한다.   
코틀린에서도 인터페이스는 제한 없이 구현할 수 있으며 클래스는 1개만 상속 가능하다.
자바의 @Override 애노테이션과 비슷한 override 변경자는 상위 클래스나 상위 인터페이스 안에 있는
프로퍼티나 메소드를 오버라이드한다는 표시이다. 

> 프로퍼티도 오버라이드 한다.

자바와 달리 코틀린에서는 override 변경자를 꼭 사용해야 한다.   

```kotlin
interface Clickable{
    fun click()
    fun showOff() = println("I'm clickable!") 
}
```

인터페이스 메소드 역시 디폴트 구현을 제공할 수 있다.
자바의 경우 그 메소드 앞에 default를 붙이지만 코틀린의 경우 특별한 키워드를 붙이지 않는다.   
그냥 메소드 본문을 메소드 시그니처 뒤에 추가하면 된다.

다수의 인터페이스를 함께 구현하면 메소드의 이름이 충돌 할 수 있다. 
1. 충돌하는 메소드 선언에 대해 구현을 제공하면 된다.   
2. 여러 메소드가 디폴트 메소드를 제공하면서 그 이름이 겹치면 컴파일에 실패한다.     
3. 이 경우 겹치는 이름에 해당하는 메소드를 하나 더 오버라이드해주면 문제가 해결된다.   

> 자바에서의 활용
> 코틀린은 기본적으로 자바 6와 호환된다. 따라서 인터페이스는 디폴트 메소드를 제공하지 않는다.
> 코틀린은 디폴트 메소드가 있는 인터페이스를 자바로 이주시킬 때 일반 인터페이스와
> 디폴트 메소드 구현이 들어있는 정적 메소드의 조합으로 구성한다.
> 인터페이스에는 메소드 선언만 들어가고 생성되는 클래스에는 모든 디폴트 메소드 구현이 정적 메소드로 들어간다.
> 자바에서 코틀린 인터페이스가 구현한 메소드를 상속해 사용할 수는 없으므로 직접 구현 후 정의해야 한다.

## 1.2 open, final, abstract : default는 final
자바에서는 final로 명시하여 클래스 상속을 방지한다.   
코틀린에서는 final 키워드를 컴파일 시점에 자동적으로 붙여 상속을 기본적으로 방지한다.
따라서 어떤 클래스를 상속 가능하도록 만들려면 open 키워드를 붙여주어야 한다.
이는 메소드에도 똑같이 적용된다.

> 열린 클래스와 스마트 캐스트   
> 클래스를 기본적으로 final로 함으로써 얻을 수 있는 이점은 스마트 캐스트가 이루어진다는 점이다.
> 스마트 캐스트는 이전 라인에서 타임 검사가 이루어진 val 변수에만 적용된다.
> 이는 클래스 프로퍼티의 경우 val 이면서 커스텀 접근자가 없는 경우에만 스마트 캐스트가 적용된다는 소리이다.
> 이 요구 사항은 또한 final이어야 한다.
> 프로퍼티가 final이 아니면 프로퍼티를 상속하면서 커스텀 접근자를 정의할 수 있게되어 
> 스마트 캐스트의 요구 사항을 만족할 수 없게 됝다.
> 프로퍼티는 기본적으로 final 이므로 대부분 스마트 캐스트를 활용할 수 있으며 코드를 이해하기 쉽게 만든다.

자바처럼 코틀린에서도 abstract를 지원한다. abstract로 선언한 추상 클래스는 인스턴스화 할 수 없다.
추상 클래스에는 구현이 없는 추상 멤버가 있고 이를 하위 클래스에서 오버로이드 하는게 보통이다.

> final / 오버라이드할 수 없음 / 클래스 멤버의 기본 변경자   
> open / 오버라이드할 수 있음 / 반드시 open을 명시해야 오버라이드 할 수 있다.   
> abstract / 반드시 오버라이드해야 함 / 추상 클래스의 멤버에만 이 변경자를 붙일 수 있다.   
> override / 상위 클래스나 상위 인스턴스의 멤버를 오버라이드 함 / 오버라이드 하는 멤버는 기본적으로 open 된다.
> override 하면서 상속을 막고 싶다면 final 을 추가적으로 명시해야 한다.

인터페이스의 멤버는 항상 열려있으며 final로 변경할 수 없다. 인스턴스 멤버에 구현이 없으면 자동적으로 abstract가 되며
키워드를 생략해도 된다.

## 4.1.4 가시성 변경자 : 기본적으로 공개
기본적으로 코틀린의 가시성 변경자는 자바와 비슷하게 동작한다. public / protected / private는 자바와 같다.
하지만 default 가시성 제어자의 경우 자바와 차이점이 있다.
코틀린에서는 변경자가 없는 경우 모두 public이 된다.

자바의 기본 가시성 (package-private) 는 코틀린에 없다. 코틀린에서는 패키지를 네임스페이스를 분리하는 용도로만 사용한다.
따라서 패키지는 가시성 제어에 사용되지 않는다.

패키지 전용 가시성의 대안으로 코틀린에서는 internal을 사용한다. internal은 모듈 내부에서만 볼 수 있다.
모듈은 한번에 한꺼번에 컴파일되는 코틀린 파일을 의미한다.

모듈 내부 가시성은 진정한 가시성을 제공한다. 자바의 경우
패키지가 같은 클래스를 선언만 하면 어떤 프로젝트의 외부 코드라도 가시성을 무시할 수 있고 캡슐화가 손상된다.

코틀린에서는 최상위 선언에 대해 private 가시성을 허용한다. (클래스 / 함수 / 프로퍼티 포함)
최상위 선언에 private를 적용하면 그 선언의 내용은 파일 내부에서만 사용가능하다.

> public -> internal -> protected -> private : private로 갈수록 낮아진다

> 변경자 /클래스 멤버 / 최상위 선언
> public(기본 가시성) / 모든 곳에서 볼 수 있다 / 모든 곳에서 볼 수 있다    
> internal / 같은 모듈 안에서 볼 수 있다 / 같은 모듈 안에서 볼 수 있다   
> protected / 하위 클래스 안에서만 볼 수 있다 / (최상위 선언에 적용할 수 없음)   
> private / 같은 클래스 안에서만 볼 수 있다 / 같은 파일 안에서만 볼 수 있다

같은 모듈 내에서 자신 보다 낮은 가시성을 가진 대상은 접근할 수 없다.
1. public 은 public 만 볼 수 있다.
2. internal 은 internal / public 을 볼 수 있다.
3. private 는 private / internal / public을 볼 수 있다.

> 코틀린의 private 클래스는 자바에서 사용할 수 없다.(자바에서는 private class가 없기 때문)
> 따라서 내부적으로 코틀린은 private 클래스를 패키지-전용 클래스로 컴파일 한다.
> internal의 경우 자바에서 public으로 사용된다.

> 코틀린 선언과 자바의 선언은 이런 차이가 있기 때문에 코틀린에서 접근할 수 없는 대상이
> 자바에서 접근가능한 경우가 생길 수 있다. 
> 다른 모듈에 정의된 internal 클래스나 internal 최상위 선언을 모듈 외부의 자바에서는 접근 할 수 있다.

> 코틀린에서는 protected로 정의한 멤버를 자바에서는 같은 패키지에 속하면 접근할 수 있다.   
> 자바의 가시성 순서 : public -> protected(같은 패키지면 제한 x, 다른 패키지는 상속) -> package-private -> private   

> 코틀린 컴파일러는 internal 멤버의 이름을 바꾼다. 기술적으로 nternal 멤버를 자바에서 사용할 수 있지만 이름이 보기 불편하고 가독성이 떨어진다.
> 이러한 방식을 취하는 이유는 이름의 충돌을 방지하여 의도치않은 오류를 방지하고 모듈 외부에서 사용하는 일을 막기 위함이다.

코틀린과 자바 가시성의 또 다른 차이는 코틀린에서는 외부 클래스가 내부 클래스나 중첩된 클래스의 private 멤버에 접근할 수 없다는 점이다.

## 4.1.4 내부 클래스와 중첩된 클래스 : 기본적으로 중첩 클래스
자바처럼 코틀린에서도 클래스 안에 다른 클래스를 선언 할 수 있다.    
클래스 안에 다른 클래스를 선언하면 도우미 클래스를 캡슐화하거나 코드 정의를 코드 사용처와 가까이 할 수 있다.

자바와의 차이는 코틀린의 중첩 클래스는    
명시적으로 요청하지 않는 한 바깥족 클래스의 인스턴스에 대한 접근 권한이 없다.    
(내부 클래스가 외부 클래스의 인스턴스 접근 x)   

자바에서는 다른 클래스 내부에 정의한 클래스를 직렬화 할 때 그 클래스는 자동으로 내부 클래스로 취급된다.
따라서 Outer 클래스의 참조가 묵시적으로 포함된다. 그 참조가 직렬화를 방해한다.
이를 방지하려면 내부 클래스를 static 으로 선언해야 한다. 그러면 바깥쪽 클래스에 대한 묵시적 참조가 제거된다.

반면 코틀린의 동작방식은 정반대이다.
코틀린 중첩 클래스에 아무런 변경자가 붙지 않으면 자바 static 중첩 클래스와 동일하다.
이를 내부 클래스로 변경해서 바깥쪽 클래스의 참조를 포함하고 싶다면 inner 변경자를 붙여야한다.

> 클래스 B안에 정의된 클래스 A / in 자바 / in 코틀린   
> 중첩 클래스(참조 저장 x) / static class A / class A   
> 내부 클래스(참조 저장) / calss A / inner class A

코틀린에서는 바깥쪽 참조 역시 다르게 표현한다. 바깥쪽 클래스를 참조하려면
this@Outer를 써야 한다.
 
## 봉인된 클래스 : 클래스 계층 정의 시 계층 확장 제한
보통 when 을 사용하면 else를 붙여 예외에 대응하도록 강제한다.   
하지만 이러한 경우는 번거로운 경우가 많다.      
클래스가 될 수 있는 값의 타입을 한정 할 수 있다면 else를 반드시 병기할 필요가 없다.   
코틀린에서는 이러한 문제를 봉인된 클래스를 구현하도록 하여 해결한다.   
상위 클래스에 sealed 변경자를 붙이면 상위 클래스를 상속한 하위 클래스 정의를 제한할 수 있다.

```kotlin
sealed class Expr{
    class Num() : Expr()
    class Sum() : Expr()
}
```

내부적으로 sealed 클래스는 private 생성자를 가진다. 따라서 인스턴스를 내부에서만 생성 할 수 있따.
또한 sealed 인터페이스는 정의할 수 없다. 이를 자바 쪽에서 구현하지 못하게 막을 수단이 없기 때문이다.
 