# ORM

ORM이란, Object와 Relation 간의 불일치 문제를 해결하기 위한 도구다.   
자바에서는 데이터베이스 서버에 접속해서 쿼리를 수행하고, 그 결과를 프로그램에서 사용하도록 JDBC API를 제공한다.   

추상화 계층 없이 SQL을 통해서 제어하면 빠르게 개발이 가능하지만, 
상태 변화가 객체가 아니라 데이터베이스 상에서 일어나므로 SQL을 수행하는 코드를 반복적으로 작성해야 한다.   

ORM을 사용하면 반복을 줄이고 객체 중심의 설계에 집중할 수 있다.   

JPA는 JDBC와 마찬가지로 그 자체로 스펙인 동시에 API를 제공한다.   

## Spring Data JPA
자바 진영에서 주로 쓰이는 ORM 기술은 JPA와 Hibernate이다.   
Spring Data JPA는 Spring Data 프로젝트의 하위 프로젝트로   
Hibernate와 JPA에 비해 Spring을 쓰는 환경에 적용이 수월하다.   

JPA와 Spring Data JPA는 모두 데티어 저장소 처리를 위해 만들었다.

### JPA
JPA 스펙을 만들 당시 NoSQL이 존재하지 않았고,    
따라서 객체와 관계형 데이터베이스의 매핑이 주된 요구사항이었다.
이에 따라 Spring은 이러한 점을 보완하기 위해 새로운 스펙을 재정하였고 Spring Data가 그 스펙이다.   

### Spring Data
스프링 데이터는 NOSQL 또는 RDBMS 두개 모두를 목표로 하며
추상화된 인터페이스를 통해 MySQL, ElasticSearch, Redis등 다양한 저장소를 활용할 수 있다.   

### 의존성 추가
```kotlin
// in build.gradle.kts
plugins{
    kotlin("plugin.jpa") version "1.4.21"
}

implementation("org.springframework.boot:spring-boot-starter-data-jpa")

runtimeOnly("com.h2database:h2")
runtimeOnly("mysql:mysql-connector-java")

// in application.property
```
### DB 사용을 위한 application.property 설정
```properties
// mysql DB를 사용하는 경우 
spring.datasource.url=jdbc:mysql://mysql_db_uri
spring.datasource.username=root
spring.datasource.password=password
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

spring.jpa.database-platform=org.hibernate.dialect.MySQL5InnoDBDialect

// h2 DB를 사용하는 경우
spring.datasource.url=jdbc:h2:mem:testdb;DB_CLOSE_ON_EXIT=FALSE
spring.datasource.username=sa
spring.datasource.password=password
spring.datasource.driver-class-name=org.h2.Driver
spring.h2.console.enabled=false

spring.jpa.database-platform=org.hibernate.dialect.H2Dialect
```

plugin.jpa 플러그인은 코틀린 클래스에 기본생성자를 추가해준다.   
그러면 Entity를 생성할 때 별도로 기본 생성자를 생성하거나, 프로퍼티에 기본값을 부여할 필요 없다.   

application.property에는 db 정보와 jpa가 사용할 db 정보를 작성한다.

### Spring Data JPA의 Repository 구조

스프링을 사용할 때 클래스들을 ApplicationContext에 저장하듯이   

ORM을 사용할 때는 
엔티티 매니저로 영속성 콘텍스트를 제어해서    
자바 객체와 데이터베이스 간의 데이터 통신 및 동기화를 제어한다.

이 엔티티 매니저의 기능을 보다 쉽게 사용할 수 있도록 Repository인터페이스를 제공하고   
Repository 인터페이스를 확장해서 기본적인 CRUD메서드를 사용할 수 있는
구현체도 제공한다.

1. CrudRepository 인터페이스는 save, find, delete 를 제공한다.
2. PagingAdSortingRepository 는 paging처리를 할 수 있도록 find 메서드에 파라미터로 sort 객체와
pageable 객체를 추가했다.
3. JpaRepository는 객체 간에 동기화 할 수 있는 save와 saveAndFlush 메서드를 추가한 이터페이스다.

## 2.2 데이터베이스와 객체 매핑
### Entity 클래스 설정
Entity란 스키마의 내용을 클래스로 표현할 수 있는 대상이다.      
@Entity 어노테이션을 선언하는 것으로 엔티티 매니저가 관리해야 할 대상으로 설정할 수 있다.   

### DB와 키 매핑
DB와 클래스 간의 매핑 시에 가장 중요한 역할을 하는 요소는 바로 키값이다.   
DB에서 제공하는 auto_increment, sequence와 같이 유일성을 보장하는 요소들과   
키값 역할을 하는 클래스의 필드를 매핑함으로써 유일성을 보장받을 수 있다.   

데이터베이스에서 제공하는 시퀀스 값 또는 주 키 매핑이 필요한 경우 @Id 어노테이션을 사용한다.   

규칙 : TABLE, SEQUENCE, IDENTITY, AUTO

### Entity : 클래스와 테이블 매핑

```kotlin
@Entity
@Table(name="tbl_user")
class UserEntity(
		@Id
		@GeneratedValue(strategy=GenerationType.AUTO)
		val id : Long =0,
		val userName : String,
		val age : Int,
		var createdAt : Date = Date(),
        @Column(name="role")
		@Enumerated(EnumType.ORDINAL)
		val userRole: UserRole = UserRole.USER
) : Serializable{
	@PrePersist
	fun beforeCreate(){
		val tomorrow = LocalDate.now().plusDays(1)
		createdAt = Date.from(tomorrow.atStartOfDay().toInstant(ZoneOffset.UTC))
	}
}

```

@Entity 어노테이션을 클래스명 위에 선언하고 id 어노테이션을 이용해 키를 지정할 수 있다.  
실제 테이블명과 클래스명이 다른 경우 @Table 어노테이션을 추가해서 테이블명을 지정할 수 있다.

문자열이나 숫자 외에 날짜와 같이 매핑 시에 값 참조를 위해서   
미리 인스턴스가 생성되어야 하는 필드는 콜백 메서드를 사용해서 값을 세팅할 수 있다.   

@PrePersis를 사용하면 필드를 영속성 콘텍스트가 로드할 때 메소드를 호출하여 날짜 값이 할당된다.   
예제에서는 다음 날의 LocalDate를 구한 후 Date로 변환해 값을 대입한다.

### 값 매핑
보통 특정한 값의 도메인은 이산적인 값의 집합이며 enum을 통해 표현하다.    
ORM에서는 그러한 값은 @Enumerated 를 사용한다.

```kotlin
enum class UserRole{
	USER, ADMIN
}

// class User : s
        @Column(name="role")
		@Enumerated(EnumType.ORDINAL)
		val userRole: UserRole = UserRole.USER
// : e
```

@Enumerated 옵션에서는 enum 값을 int로 저장할지 string으로 저장할지 선택할 수 있다.
> ORDINAL : int   
> STRING : string

### Repository
Entity 클래스는 데이터베이스 테이블을 매핑하는 역할을 하고,    
Repositoy는 Entity 조작에 필요한 쿼리를 메소드화해서 사용하도록 해준다.   
기본적으로 JpaRepositor를 상속하면 CRUD를 구현할 수 있다.

```kotlin
@Repository
interface UserRepository : JpaRepository<UserEntity, Long>{
}
```

필드 검색을 하기 위해서는 메서드 이름으로 쿼리를 생성할 수 있다.   
> fun findBy + 필드명(파라미터) : 반환타입

```kotlin
@Repository
interface UserRepository : JpaRepository<UserEntity, Long>{
	fun findByUserName(@Param("userName") userName : String) : UserEntity
}
```

UserEntity 클래스에서는 사용자명 필드의 이름을 userName으로 선언했다.   
따라서 메서드에서도 똑같이 findByUserName 카멜 표기로 변경하여 맞춰준다.


