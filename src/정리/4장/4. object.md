# object 키워드 : 클래스 선언과 인스턴스 생성

코틀린에서는 object를 다양한 상황에서 사용하다. 
각 상황에 공통점이 있는대 모든 경우 클래스를 정의하면서 동시에 인스턴스를 생성한다는 것이다.
object 키워드를 사용하는 상황은 다음과 같다.

1. 객체 선언 : 싱글턴 정의
2. 동반 객체 : 
3. 자바의 무명 내부 클래스 대신 사용

## 객체 선언 : 싱글턴
객체지향 시스템을 설계하면 인스턴스가 하나만 필요한 클래스가 유용한 경우가 많다.   
자바에서는 보통 클래스의 생성자를 private로 제한하고    
정적인 필드에 그 클래스의 유일한 객체를 저장하는 싱글턴 패턴을 사용한다.   

코틀린은 객체 선언 기능을 제공하여 싱글턴을 언어 차원에서 지원한다.
객체 선언은 클래스 선언과 그 클래스에 속한 단일 인스턴스의 선언을 합친 선언이다.

object 키워드를 사용하면 (class 키워드 없이) 클래스를 정의하면서 인스턴스를 1개 선언한다.   
클래스와 마찬가지로 프로퍼티, 메소드, 초기화 블록이 들어갈 수 있다.
하지만 생성자는 따로 사용되지 않고 컴파일 시점에 자동으로 생성된다.

이에 대한 사용은 자바의 static을 사용하듯이 클래스 명을 변수로 취급하여 사용한다.

객체 선언도 클래스나 인스턴스를 상속할 수 있으며 내부에 상태를 관리할 필요가 없을 때 유용하다.
예를 들어 java.util.Comparator 처럼 비교자를 제공하는 클래스는 1개만 있으면 된다.

### cf) 프레임워크와 객체 선언
코틀린이 제공하는 싱글턴 기능은 생성자 파라미터를 지정할 수 없다. 이러한 제약 때문에
객체를 대체하거나 객체의 의존관계를 바꾸기 어렵다. 따라서
그러한 기능이 필요하면 자바와 마찬가지로 DI Framework의 기능을 사용하는 편이 낫다.

### 클래스 내부에서의 객체 선언 
이는 자바의 내부 static 클래스와 비슷한 개념으로 클래스 안에서 객체를 선언한다.   
객체 선언이므로 인스턴스는 1개만 생성된다.   
어떤 클래스의 인스턴스를 비교하는 Comparator를 클래스 내부에 정의하는게 결합도를 상승시킨다.

## 동반 객체 : 팩토리 메소드와 정적 멤버가 들어가는 장소
코틀린 클래스 안에는 정적 멤버가 없다. 코틀린에서는 자바의 static 키워드를 지원하지 않는다.
대신 코틀린에서는 패키지 수준에서 최상위 함수와 객체 선언을 을 활용한다.

대부분의 경우 최상위 함수를 사용하는 것을 권장한다. 하지만 최상위 함수는 다른 클래스 내부의
private 멤버에 접근할 수 없다. 따라서 이러한 private 멤버에 접근하려면 클래스 내부에
중첩된 객체 선언을 해야 한다.

### companion 
compoanion 키워드를 사용하면 object를 동반 객체로 만들 수 있다.
동반 객체의 메소드나 변수는 자바의 정적 객체나 메소드 처럼 사용할 수 있다.

```kotlin
class Outer{
    fun outerMethod(){
        println("I'm Outer")
    }

    companion object Inner{
        fun innerMethod(){
            println("I'm Inner")
        }
    }
}
```

companion object 는 자바의 static 성질을 가지고 있다. 
1. innerMethod 에서 Outer의 멤버에 접근할 수 없다.
2. Outer.innerMethod() 처럼 클래스 명을 통해 호출한다. 
이 때 Inner(companion object의 이름)를 생략 할 수 있다.

이러한 성질 때문에 동반 객체는 private 생성자를 호출하지 좋은 위치가 된다.
동반 객체는 자신을 둘러싼 클래스의 private 생성자에 접근할 수 있다.

따라서 이러한 성질은 팩토리 메소드를 구현할 때 유용하다.
공개하고 싶지 않은 생성자를 private로 숨기고, 공개하고 싶은 이름과 파라미터로
클래스의 생성 방법을 제한 할 수 있다.

### 동반 객체를 일반 객체처럼 사용
동반 객체는 클래스 안에 정의된 일반 객체와 같다. 따라서 다음의 성질을 가진다.
인터페이스를 상속하거나, 동반 객체 안에 확장 함수와 프로퍼티를 정의할 수 있다.

- 동반 객체에 역시 이름을 가질 수 있다.
```kotlin
Person.Loader.fromJson() // Loader는 동반객체의 이름
```
- 동반 객체는 인터페이스를 구현할 수 있다.
이 떄 특징적인 이 인터페이스를 구현한 동반 객체를 참조할 때 동반 객체의 Outer 클래스의
이름을 사용해서 참조 할 수 있다는 점이다.
```kotlin
fun main(){ 
    val comparable : Comparable<Person> = Person
    comparable.compareTo(Person("alan"))
}

class Person(val name: String){ 
    companion object : Comparable<Person>{
        override fun compareTo(other: Person): Int {
            return 0 // do Something
        }
    }
}
```

코틀린의 동반 객체는 자바에서 클래스에 정의된 정적 필드로 컴파일 된다.
따라서 자바 쪽에서 사용할 때는 Companion, 이름을 붙였다면 그 이름으로 참조할 수 있다.
Clazz.Companion

### 동반 객체 확장
확장 함수를 사용하면 기존 클래스에 새로운 메소드를 추가할 수 있다. 
자바의 정적 메소드나 코틀린의 도박 객체 메소드처럼 기존 클래스에 대해 호출할 수 있는 새로운 함수를 정의하려면 어떻게 해야할까?

C라는 클래스 안에 동반 객체가 있고 그 안에 func를 정의하면 외부에서는 func()를 C.func()로 호출할 수 있다.

예를 들어 Person의 관심사를 더 명확히 분리한다고 하자. Person 클래스는 핵심 비즈니스 로직의 일부이다. 따라서 그 모듈이
특정 데이터 타입에 의존하기를 원하지 않는다. 따라서 역직렬화 함수를 비즈니스 모듈인 Person이 아니라
클라이언트/서버 통신을 담당하는 모듈 안에 포함시키고 싶다. 
이 떄 확장함수를 사용하면 깔금한 구조를 구성할 수 있다.

fun Person.Companion.mymethod ...

마치 동반 객체 안에서 함수를 정의한 것처럼 호출할 수 있다.
하지만 실제로는 클래스 밖에서 정의한 확장 함수이다.    
이러한 동반 객체에 대한 확장 함수를 작성하려면 원래 클래스에 동반 객체를 꼭 선언해 두어야 한다.

### 객체 식 : 무명 내부 클래스를 다른 방식으로 작성
object 키워드는 무명 객체를 정의할 떄도 사용할 수 있다.    
무명 객체는 자바의 무명 내부 클래스를 대신한다.   
자바에서는 흔히 무명 내부 클래스로 구현하는 이벤트 리스너를 코틀린에서는 object를 사용해 구현할 수 있다.

```kotlin
object : Comparable<Int>{
    override fun compareTo(other: Int): Int {
        println("do Something")
        return 0
    }
}
```
object는 클래스나 인터페이스를 바로 상속하여 전달할 수 있다.    
코틀린의 무명 객체는 자바의 무명 내부 클래스와 다르게 여러 인터페이스를 구현하거나 
클래스를 확장하면서 인터페이스를 구현할 수 있다.

무명 객체에 참조를 가지고 싶다면 변수에 할당하면 된다.
