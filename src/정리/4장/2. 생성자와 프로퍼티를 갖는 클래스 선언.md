# 뻔하지 않은 생성자와 프로퍼티를 갖는 클래스 선언

자바에서는 생성자를 1개 이상 선언할 수 있다.
코틀린도 이와 비슷하지만 코틀린은 주 생성자와 부 생성자를 구분한다.

## 클래스 초기화 : 주 생성자와 초기화 블록
주 생성자의 선언에는 클래스 이름 뒤에 오는 괄호로 둘러싸인 코드를 사용한다.
```kotlin
class User(val nickname : String)
```
주 생성자는 생성자 파라미터를 지정하는 동시에 그 파라미터를 초기화한다.   
이러한 선언은 다음과 동치이다.   

```kotlin
class User constructor(_nickname : Stirng) {
    val nickname : String
    init{
        nickname = _nickname
    }
}
```

constructor 키워드는 주 생성자나 부 생성자를 선언할 때 사용한다.
init 키웓는 초기화 블록으로 사용한다.   
초기화 블록에는 클래스의 객체가 생성될 떄 실행될 초기화 코드가 들어간다.   
주 생성자의 코드 블록은 제한적이기 때문에 초기화 블록이 필요하다.

프로퍼티를 초기화하는 코드를 선언에 포함시킬 수 있을 정도로 간단하다면(단순 대입) 초기화 블록을 사용할 필요가 없다.
주 생성자 앞에 별다른 가시성 변경자가 없다면 constructor 키워드는 생략 할 수 있다.

```kotlin
class User(_nickname : String){
    val nickname = _nickname
}
```

클래스 본문에서 val 키워드를 통해 프로퍼티를 정의했다. 하지만 주 생성자의 파라미터로 프로퍼티를 초기화 할 거라면
생성자 파라미터 이름 앞에 val을 추가하는 방식으로 간략화 할 수 있다.
함수 파라미터와 마찬가지로 생성자 파라미터에도 디폴트 값을 지정할 수 있다.

> 모든 생성자 파라미터에 디폴트 값을 지정하면 컴파일러는 자동으로 파라미터 없는 생성자를 생성한다.
> 이러한 기법은 프레임워크와의 통합을 도와준다.

클래스에 수퍼 클래스가 있다면 주 생성자에서 기반 클래스의 생성자를 호출해야 한다.
기반 클래스를 초기화 하려면 기반 클래스 이름 뒤에 괄호를 치고 생성자 인자를 넘긴다.

아무런 지정을 하지 않으면 컴파일러는 자동으로 인자업는 디폴트 생성자를 만든다.

이러한 규칙들로 인해 기반 클래스의 이름 뒤에는 이를 초기화하는 괄호가 반드시 들어간다.
인터페이스는 별도로 생성하지 않으므로 이를 통해 상속한 인터페이스와 클래스를 구분할 수 있다.

이러한 클래스의 생성을 막고 싶다면 생성자 앞에 private 가시성 제어자를 추가한다. 
그러면 클래스의 생성자를 호출할 수 없다.

## 4.2.2 부 생성자 : 상위 클래스를 다른 방식으로 초기화
일반적으로 코틀린에서는 생성자가 여럿 잇는 경우가 적다. 

> 인자에 대한 디폴트 값을 제공하기 위해 부 생성자를 여러개 만들지 말고, 디폴트 값을 시그니처에 명시하는 것이 좋다.

부 생성자는 super() 를 사용해서 자신의 수퍼 클래스의 생성자를 호출한다.
또한 자바와 마찬가지로 생성자에서 this()를 통해 자신의 다른 생성자를 호출할 수 있다.

> 클래스에 주 생성자가 없다면 모든 부 생성자는 반드시 상위 클래스를 초기화하거나   
> 다른 생성자에게 생성을 위임해야 한다. (이는 수퍼 클래스의 생성자를 호출하기 위함)

부 생성자가 필요한 주된 이유는 자바와의 상호 운용성이다. 그 외에는 파라미터의 목록이 다른 생성 방법이
여러개 존재하는 경우인 경우 부 생성자를 여럿 두어야 한다.

## 4.2.3 인터페이스에 선언된 프로퍼티 구현
코틀린의 인터페이스는 추상 프로퍼티 선언을 넣을 수 있다.
```kotlin
interface User {
    val nickname : String
}
```

User 인터페이슬 구현하는 클래스가 nickname의 값을 얻을 수 있는 방법을 제공해야 한다는 뜻이다.
인터페이스에 있는 프로퍼티 선언에는 뒷받침 필드나 게터 정보가 들어있지 않다.
인터페이스는 아무 상태도 포함할 수 없으므로 상태를 저장할 필요가 있다면 인터페이스를 구현한
하위 클래스에서 상태 저장을 위한 프로퍼티 등을 만들어야 한다.

### 인터페이스를 구현하는 방법
```kotlin
class PrivateUser(override val nickname: String) : User

class SubscribingUser(val email : String) : User{
    override val nickname : String
        get() = email.substringBefore('@')
}

class FackbookUser(val accountId : Int) : User{
    override val nickname = getFacebookName(accountId)
}       
```

1. PrivateUser는 주 생성자 안에 프로퍼티를 직접 선언하는 간단 구문을 사용한다.   
이 프로퍼티는 User의 추상 프로퍼티를 구현하므로 override를 표기해야 한다.
2. SubscribingUser는 커스텀 게터를 사용해 nickname 프로퍼티를 설정한다.   
이 경우 뒷받침 필드에 값을 저장하지 않고 매번 이메일 주소에서 별명을 계산한다.
3. FacebookUser에서는 초기화를 통해 nickname 값을 초기화한다.    
따라서 nickname 필드 자체에 값이 저장된다.

2 의 경우 호출시마다 매번 계산하는 커스텀 게터를 활용하고    
3 은 객체 초기화 시 계산한 데이터를 뒷바침 필드에 저장하고 참조만 한다.

> 인터페이스에는 추상 프로퍼티뿐 아니라 게터와 세터가 있는 프로퍼티를 선언할 수도 있다.
> 물론 이 경우 게터와 세터는 뒷받침 필드를 참조 할 수 없다.
> 뒷받침 필드가 있다면 상태를 추가하는 셈이며 인터페이스는 상태를 관리하지 않는다.

## 4.2.4 게터와 세터에서 뒷받침하는 필드에 접근
지금까지 프로퍼티의 두 유형(값을 저장하는 프로퍼티 / 커스텀 접근자가 매번 계산)을 보았다.
이제는 이 두 유형을 조합해 어떤 값을 저장하되 그 값을 변경하거나 읽을 때 정해진
로직을 실행하는 유형의 프로퍼티를 만드는 방법을 생각해보자.

값을 저장하는 동시에 로직을 실행하려면 접근자 안에서 프로퍼티를 뒷받침하는 필드에 접근해야 한다.

저장된 값의 변경 이력을 로그에 남기는 경우를 생각해보자.
그 경우 변경 가능한 프로퍼티를 정의해야 하며 프로퍼티 값을 바꿀 때마다 약간의 코드를
추가적으로 실행해야 한다.

```kotlin
class user(val name: String){
    var address : String = "unspecified"
        set(value : String){
            println("기록합니다")
            field = value
        }
}
```

접근자의 본문에서는 field라는 특별한 식별자를 통해 뒷받침 필드에 접근할 수 있다.   
게터에서는 field 값을 읽을 수만 있고, 세터에서는 field 값을 읽거나 쓸 수 있다.

컴파일러는 디폴트 접근자 구현을 사용하건 커스텀 접근자를 사용하건 뒷받침 필드를 생성한다.
> 다만 field를 사용하지 않는 커스텀 접근자 구현을 정의한다면 뒷받침하는 필드는 존재하지 않는다.   
> val인 경우 게터에 field가 없어야 한다.    
> var인 경우 게터와 세터 모두에 field가 없어야 한다.

## 4.2.5 접근자의 가시성 변경
떄로는 접근자의 기본 구현을 바꿀 필요는 없지만 가시성을 바꿀 필요가 있다.
접근자의 가시성은 기본적으로 프로퍼티의 가시성과 같다. 하지만 원한다면 get이나 set 앞에
가시성 변경자를 추가해 새로운 가시성을 부여할 수 있다.

```kotlin
class LengthCounter{
    var counter : Int = 0
        private set
    fun addWord(word : Stirng){
        counter+=word.length
    }
}
```

단어의 길이가 누적되므로 파라미터는 var을 사용한다. 하지만 이는 외부에서 함부로
변경하면 안돼므로 set에 private를 부여한다.
그러면 내부적으로만 프로퍼티의 값을 바꿀 수 있다.
