# 2. 리플렉션 : 실행 시점에 코틀린 객체 내부 관찰

리플렉션은 실행 시점에(동적으로) 객체의 프로퍼티와 메소드에 접근할 수 있게 해주는 방법이다.   

보통 객체의 메소드나 프로퍼티에 접근할 때는 프로그램 소스코드 안에 구체적인 선언이 있는   
메소드나 프로퍼티 이름을 사용하며, 
컴파일러는 컴파일 시점에 실제로 그 이름이 존재하는지 찾아 존재함을 보장한다.

하지만 타입과 관계없이 객체를 다뤄야 하거나 객체가 제공하는 메소드나 프로퍼티 이름을
오직 실행 시점에만 알 수 있는 경우가 있다.   

JSON 직렬화 라이브러리가 그런 경우다.
직렬화 라이브러리는 어떤 객체든 JSON으로 변환할 수 있어야 하고,
실행 시점이 되기 전까지는 라이브러리가 직렬화할 프로퍼티나 클래스에 대한 정보를 알 수 없다.   

코틀린에서 리플렉션을 사용하려면 두 가지 서로 다른 리플렉션 API를 다뤄야 한다.
1. 자바가 java.lang.reflect 패키르를 통해 제공하는 표준 리플렉션 : 코틀린 클래스는   
일반 자바 바이트코드로 컴파일되므로 완벽히 지원된다.
2. 코틀린 kotlin.reflect 패키지를 통해 제공하는 코틀린 리플렉션 API   
이 API는 자바에는 없는 프로퍼티나 널이 될 수 있는 타입과 같은 코틀린 고유 개녀에 대해 리플렉션을 제공한다.
하지만 자바 리플렉션 API를 완전히 대체할 수 있는 복잡한 기능을 제공하지는 않는다.
따라서 때로는 자바 리플렉션을 사용해야 하는 경우가 있다.   

## 2.1 코틀린 리플렉션 APi : KClass, KCallable, KFunction, KProperty
코틀린 리플렉션 API를 사용할 때 처음 접하게 되는 것은 클래스를 표현하는 KClass이다.
java.lang.Class에 해당하는 KClass를 사용하면 클래스 안에 있는 모든 선언을 열거하고
각 선언에 접근하거나 클래스의 상위 클래스를 얻는 등의 작업이 가능하다.   

MyClass::class라는 식을 쓰면 KClass의 인스턴스를 얻을 수 있다. 
실행 시점에 객체의 클래스를 얻으려면 먼저 객체의 javaClass 프로퍼티를 사용해    
객체의 자바 클래스를 얻어야 한다.
javaClass는 자바의 java.lang.Object.getClass()와 같다.   

일단 자바 클래스를 얻었으면 kotlin 확장 프로퍼티를 통해 자바에서 코틀린 리플렉션 APi로 접근할 수 있다.  

```kotlin
    val p = Person("Alan",27)
    val kClass : KClass<Person> = p.javaClass.kotlin

    println(kClass.simpleName) // class name 출력
    kClass.memberProperties.forEach {println(it.name)} // 프로퍼티 출력
```

KClass에 대해 사용할 수 있는 다양한 기능은 실제로 kotlin-reflect라이브러리를 통해 제공하는 확장 함수다.   
이런 확장 함수를 사용하려면 import kotlin.reflect.full.*로 확장 함수 선언을 임포트해야 한다.

클래스의 모든 멤버의 목록이 KCallable 인스턴스의 컬렉션임을 확인할 수 있다.    
KCallable은 함수와 프로퍼티를 아우르는 공통 상위 인터페이스다.   
그 안에는 call 메소드가 들어있다. call을 사용하면 함수나 프로퍼티의 게터를 호출할 수 있다.   

```kotlin
interface KCallable<out R>{
    fun call(vararg args: Any?) : R
}
``` 

call을 사용할 때 함수 인자를 vararg 리스트로 전달한다. 다음 코드는 리플렉션이 제공하는
call을 사용해 함수를 호출할 수 있음을 보여준다.

```kotlin
fun main(){
    val kFunction = ::foo
    kFunction(42)
    kFunction.call(42)
}

fun foo(x:Int) = println(x)
```

이제는 ::foo 식의 값 타입이 리플렉션 API에 있는 KFunction 클래스의 인스턴스임을 알 수 있다.
이 함수 참조가 가리키는 함수를 호출하려면 KCallable.call 메소드를 호출한다.   

call에 넘긴 인자의 개수와 원래 함수에 정의된 파라미터 개수가 맞아 떨어져야 한다. 
인자의 개수가 다르면 IllegalArgumentException이 발생한다.   

::foo의 타입 KFunction1<Int, Unit>에는 파라미터와 반환 값 타입 정보가 들어있다.   
1은 이 함수의 파라미터가 1개라는 의미다. 
Kfunction1 인터페이스를 통해 함수를 호출하려면 invoke 메소드를 사용해야 한다.
invoke는 정해진 개수의 인자만들 받아들이며 KFunction1 제네릭 인터페이스의 첫 번째 타입 파라미터와 같다.   

```kotlin
fun sum(x:Int, y:Int) = x + y

fun main(){
    val kFunction : KFunction2<Int,Int, Int> = ::sum
    println(kFunction.invoke(1,2))
}
```

kFunction으로 메소드를 호출할 때는 인자 개수나 타입이 맞아 떨어지지 않으면 컴파일이 안 된다.   
따라서 인자 타입과 반환 타임을 모두 다 안다면 invoke 메소드를 호출하는 편이 낫다.   
call 메소드는 모든 타입의 함수에 적용할 수 있는 일반적인 메소드지만 타입 안전성을 보장해주지는 않는다.   

### KfunctionN 인터페이스는 언제 정의되는가?
KFunction1과 같은 타입은 파라미터 개수가 다른 여러 함수를 표현한다.    
각 KFunctionN 타입은 KFunction을 확장하며, N과 파라미터 개수가 같은 invoke를 추가로 포함한다.   
예를 들어 KFunction2<P1,P2, R>에는 operator fun invoke(p1:P1, p2:P2):R 선언이 들어있다.   

이런 함수 타입은 컴파일러가 생성한 합성 타입이다. 따라서 kotlin.reflect 패키지에서
이런 타입의 정의를 찾을 수는 없다.   
코틀린에서는 컴파일러가 생성한 합성 타입을 사용하기 때문에 원하는 수만큼 많은 파라미터를 갖는 함수에 대한
인터페이스를 사용할 수 있다.   
합성 타입을 사용하기 때문에 코틀린은 kotlin - runtime.jar의 크기를 줄일 수 있고,    
함수 파라미터 개수에 대한 인위적인 제약을 피할 수 있다.   

KProperty의 call 메소드를 호출할 수도 있다. KProperty의 call은 프로퍼티의 게터를 호출한다.   
하지만 프로퍼티는 get 메소드를 사용하면 된다.

get 메소드에 접근하려면 프로퍼티가 선언된 방법에 따라 올바른 인터페이스를 사용해야 한다.

1. 최상위 프로퍼티 : KProperty0의 인스턴스으로 표현
KProperty0 안에는 인자가 없는 get 메소드가 있다.   

2. 멤버 프로퍼티 : KProperty1의 인스턴스로 표현
KProperty1 에는 인자가 1개인 get 메소드가 있다.   
멤버 프로퍼티는 어떤 객체에 속해 있는 프로퍼티이므로 멤버 프로퍼티의 값을 가져오려면    
get 메소드에게 프로퍼티를 얻고자 하는 객체 인스턴스를 넘겨야 한다.   

```kotlin
val person = Person("Alan", 27)
val memberProperty = Person::age
println(memberProperty.get(person))
```
   
위 예제는 memberProperty 변수에 프로퍼티 참조를 저장한 다음    
get을 호출하여 인스턴스의 프로퍼티 값을 가져온다. 
따라서 memberProperty가 Person 클래스의 age 프로티를 참조한다면    
memberProperty.get(person)은 동적으로 person.age를 가져온다.

KProperty1은 제네릭 클래스다. memberProperty 변수는 KProperty<Person, Int> 타입이다.   
첫 번째 타입 파라미터는 수신 객체 타입, 두 번쨰 파라미터는 프로퍼티 타입을 표현한다.   
따라서 수신 객체를 넘길 때는 KProperty1의 타입 파라미터와 일치하는 타입의 객체만을 넘길 수 있다.   

최상위 수준이나 클래스 안에 정의된 ㅍ로퍼티만 리플렉션으로 접근할 수 있고    
함수의 로컬 변수에는 접근할 수 없다.   
함수 안에서 로컬 변수 x를 정의하고 ::x로 그 변수에 대한 참조를 얻으려 시도하면 
"References to variables aren't supported yet" 오류를 확인할 수 있다.   

KProperty와 KMutableProperty에 선언된 Getter와 Setter인터페이스로   
프로퍼티 접근자를 함수처럼 다룰 수 있다. 
따라서 접근자 메소드에 붙어 있는 애노테이션을 알아내려면 Getter와 Setter를 통해야 한다.

Getter와 Setter는 모두 KFunction을 확장한다.

> KProperty1<T,R> 은 람다 (T) -> R 을 상속한다   
> 따라서 collection의 map과 같은 메소드에 사용가능한것이다.

## 2.2 리플렉션을 사용한 객체 직렬화 구현

우선 제이키드의 직렬화 함수 선언을 살펴보자.
```kotlin
fun serialize(obj:Any) : String
```
이 함수는 객체를 받아서 그 객체에 대한 JSON 표현을 문자열로 돌려준다.
이 함수는 객체의 프로퍼티와 값을 직렬화하면서 StringBuilder 객체 뒤에 직렬화한 문자열을 추가한다.   
이 append 호출을 더 갈결하게 수행하기 위해 직렬화 기능을 StringBuilder의 확장 함수로 구현한다.   

이렇게 하면 별도로 StringBuilder 객체를 지정하지 않아도 append 메소드를 편하게 사용할 수 있다.

```kotlin
private fun StringBuilder.serializeObject(x: Any){
    append(...)
}
``` 

함수 파라미터를 확장 함수의 수신 객체로 바꾸는 방식은 코틀린 코드에서 흔히 사용하는 패턴이다.
serializeObject는 StringBuilder API를 확장하지 않는다.   
serializeObject의 용도는 이 모듈을 벗어나면 쓸모가 없으므로 private로 가시성을 지정한다.   
이를 통해 코드 블록에서 주로 사용하는 객체가 어떤 것인지 명확히 보여주고, 그 객체를 더 쉽게 다룬다.   

```kotlin
fun serialize(obj:Any) : String = buildString{
    serializeObject(obj)
}
```

이렇게 확장 함수를 정의하면 serialize는 대부분 작업을 serializeObject에 위임한다. 
게다가 확장 함수로 지정되었으므로 this 와같은 필요없는 접근자를 사용할 필요가 없어진다.  

> buildString은 내부적으로 StringBuilder를 생성해서 인자로 받은 람다에 넘긴다.   
> 람다 안에서는 StringBuilder 인스턴스를 this로 사용할 수 있다. 
> StringBuilder의 호출은 . 없이 바로 수행할 수 있다.   
> 이 코드는 람다 본문에서 serializeObject(obj)를 호출해서 직렬화한 결과를 StringBuilder에 추가한다.
   
### JSON으로 직렬화
기본적으로 직렬화 함수는 객체의 모든 프로퍼티를 직렬화한다.
1. 원시 타입이나 문자열은 적절히 JSON 수, 불리언, 문자열 값 등으로 변환된다.
2. 컬렉션은 JSON 배열로 직렬화된다.
3. 원시 타입이나 문자열, 컬렉션이 아닌 다른 타입인 프로퍼티는 중첩된 JSON 객체로 직렬화된다.   

