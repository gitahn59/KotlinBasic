# 2. 리플렉션 : 실행 시점에 코틀린 객체 내부 관찰

리플렉션은 실행 시점에(동적으로) 객체의 프로퍼티와 메소드에 접근할 수 있게 해주는 방법이다.   

보통 객체의 메소드나 프로퍼티에 접근할 때는 프로그램 소스코드 안에 구체적인 선언이 있는   
메소드나 프로퍼티 이름을 사용하며, 
컴파일러는 컴파일 시점에 실제로 그 이름이 존재하는지 찾아 존재함을 보장한다.

하지만 타입과 관계없이 객체를 다뤄야 하거나 객체가 제공하는 메소드나 프로퍼티 이름을
오직 실행 시점에만 알 수 있는 경우가 있다.   

JSON 직렬화 라이브러리가 그런 경우다.
직렬화 라이브러리는 어떤 객체든 JSON으로 변환할 수 있어야 하고,
실행 시점이 되기 전까지는 라이브러리가 직렬화할 프로퍼티나 클래스에 대한 정보를 알 수 없다.   

코틀린에서 리플렉션을 사용하려면 두 가지 서로 다른 리플렉션 API를 다뤄야 한다.
1. 자바가 java.lang.reflect 패키르를 통해 제공하는 표준 리플렉션 : 코틀린 클래스는   
일반 자바 바이트코드로 컴파일되므로 완벽히 지원된다.
2. 코틀린 kotlin.reflect 패키지를 통해 제공하는 코틀린 리플렉션 API   
이 API는 자바에는 없는 프로퍼티나 널이 될 수 있는 타입과 같은 코틀린 고유 개녀에 대해 리플렉션을 제공한다.
하지만 자바 리플렉션 API를 완전히 대체할 수 있는 복잡한 기능을 제공하지는 않는다.
따라서 때로는 자바 리플렉션을 사용해야 하는 경우가 있다.   

## 2.1 코틀린 리플렉션 APi : KClass, KCallable, KFunction, KProperty
코틀린 리플렉션 API를 사용할 때 처음 접하게 되는 것은 클래스를 표현하는 KClass이다.
java.lang.Class에 해당하는 KClass를 사용하면 클래스 안에 있는 모든 선언을 열거하고
각 선언에 접근하거나 클래스의 상위 클래스를 얻는 등의 작업이 가능하다.   

MyClass::class라는 식을 쓰면 KClass의 인스턴스를 얻을 수 있다. 
실행 시점에 객체의 클래스를 얻으려면 먼저 객체의 javaClass 프로퍼티를 사용해    
객체의 자바 클래스를 얻어야 한다.
javaClass는 자바의 java.lang.Object.getClass()와 같다.   

일단 자바 클래스를 얻었으면 kotlin 확장 프로퍼티를 통해 자바에서 코틀린 리플렉션 APi로 접근할 수 있다.  

```kotlin
    val p = Person("Alan",27)
    val kClass : KClass<Person> = p.javaClass.kotlin

    println(kClass.simpleName) // class name 출력
    kClass.memberProperties.forEach {println(it.name)} // 프로퍼티 출력
```

KClass에 대해 사용할 수 있는 다양한 기능은 실제로 kotlin-reflect라이브러리를 통해 제공하는 확장 함수다.   
이런 확장 함수를 사용하려면 import kotlin.reflect.full.*로 확장 함수 선언을 임포트해야 한다.

클래스의 모든 멤버의 목록이 KCallable 인스턴스의 컬렉션임을 확인할 수 있다.    
KCallable은 함수와 프로퍼티를 아우르는 공통 상위 인터페이스다.   
그 안에는 call 메소드가 들어있다. call을 사용하면 함수나 프로퍼티의 게터를 호출할 수 있다.   

```kotlin
interface KCallable<out R>{
    fun call(vararg args: Any?) : R
}
``` 

call을 사용할 때 함수 인자를 vararg 리스트로 전달한다. 다음 코드는 리플렉션이 제공하는
call을 사용해 함수를 호출할 수 있음을 보여준다.

```kotlin
fun main(){
    val kFunction = ::foo
    kFunction(42)
    kFunction.call(42)
}

fun foo(x:Int) = println(x)
```

이제는 ::foo 식의 값 타입이 리플렉션 API에 있는 KFunction 클래스의 인스턴스임을 알 수 있다.
이 함수 참조가 가리키는 함수를 호출하려면 KCallable.call 메소드를 호출한다.   

call에 넘긴 인자의 개수와 원래 함수에 정의된 파라미터 개수가 맞아 떨어져야 한다. 
인자의 개수가 다르면 IllegalArgumentException이 발생한다.   

::foo의 타입 KFunction1<Int, Unit>에는 파라미터와 반환 값 타입 정보가 들어있다.   
1은 이 함수의 파라미터가 1개라는 의미다. 
Kfunction1 인터페이스를 통해 함수를 호출하려면 invoke 메소드를 사용해야 한다.
invoke는 정해진 개수의 인자만들 받아들이며 KFunction1 제네릭 인터페이스의 첫 번째 타입 파라미터와 같다.   

```kotlin
fun sum(x:Int, y:Int) = x + y

fun main(){
    val kFunction : KFunction2<Int,Int, Int> = ::sum
    println(kFunction.invoke(1,2))
}
```

kFunction으로 메소드를 호출할 때는 인자 개수나 타입이 맞아 떨어지지 않으면 컴파일이 안 된다.   
따라서 인자 타입과 반환 타임을 모두 다 안다면 invoke 메소드를 호출하는 편이 낫다.   
call 메소드는 모든 타입의 함수에 적용할 수 있는 일반적인 메소드지만 타입 안전성을 보장해주지는 않는다.   

### KfunctionN 인터페이스는 언제 정의되는가?
KFunction1과 같은 타입은 파라미터 개수가 다른 여러 함수를 표현한다.    
각 KFunctionN 타입은 KFunction을 확장하며, N과 파라미터 개수가 같은 invoke를 추가로 포함한다.   
예를 들어 KFunction2<P1,P2, R>에는 operator fun invoke(p1:P1, p2:P2):R 선언이 들어있다.   

이런 함수 타입은 컴파일러가 생성한 합성 타입이다. 따라서 kotlin.reflect 패키지에서
이런 타입의 정의를 찾을 수는 없다.   
코틀린에서는 컴파일러가 생성한 합성 타입을 사용하기 때문에 원하는 수만큼 많은 파라미터를 갖는 함수에 대한
인터페이스를 사용할 수 있다.   
합성 타입을 사용하기 때문에 코틀린은 kotlin - runtime.jar의 크기를 줄일 수 있고,    
함수 파라미터 개수에 대한 인위적인 제약을 피할 수 있다.   

KProperty의 call 메소드를 호출할 수도 있다. KProperty의 call은 프로퍼티의 게터를 호출한다.   
하지만 프로퍼티는 get 메소드를 사용하면 된다.

get 메소드에 접근하려면 프로퍼티가 선언된 방법에 따라 올바른 인터페이스를 사용해야 한다.

1. 최상위 프로퍼티 : KProperty0의 인스턴스으로 표현
KProperty0 안에는 인자가 없는 get 메소드가 있다.   

2. 멤버 프로퍼티 : KProperty1의 인스턴스로 표현
KProperty1 에는 인자가 1개인 get 메소드가 있다.   
멤버 프로퍼티는 어떤 객체에 속해 있는 프로퍼티이므로 멤버 프로퍼티의 값을 가져오려면    
get 메소드에게 프로퍼티를 얻고자 하는 객체 인스턴스를 넘겨야 한다.   

```kotlin
val person = Person("Alan", 27)
val memberProperty = Person::age
println(memberProperty.get(person))
```
   
위 예제는 memberProperty 변수에 프로퍼티 참조를 저장한 다음    
get을 호출하여 인스턴스의 프로퍼티 값을 가져온다. 
따라서 memberProperty가 Person 클래스의 age 프로티를 참조한다면    
memberProperty.get(person)은 동적으로 person.age를 가져온다.

KProperty1은 제네릭 클래스다. memberProperty 변수는 KProperty<Person, Int> 타입이다.   
첫 번째 타입 파라미터는 수신 객체 타입, 두 번쨰 파라미터는 프로퍼티 타입을 표현한다.   
따라서 수신 객체를 넘길 때는 KProperty1의 타입 파라미터와 일치하는 타입의 객체만을 넘길 수 있다.   

최상위 수준이나 클래스 안에 정의된 ㅍ로퍼티만 리플렉션으로 접근할 수 있고    
함수의 로컬 변수에는 접근할 수 없다.   
함수 안에서 로컬 변수 x를 정의하고 ::x로 그 변수에 대한 참조를 얻으려 시도하면 
"References to variables aren't supported yet" 오류를 확인할 수 있다.   

KProperty와 KMutableProperty에 선언된 Getter와 Setter인터페이스로   
프로퍼티 접근자를 함수처럼 다룰 수 있다. 
따라서 접근자 메소드에 붙어 있는 애노테이션을 알아내려면 Getter와 Setter를 통해야 한다.

Getter와 Setter는 모두 KFunction을 확장한다.

> KProperty1<T,R> 은 람다 (T) -> R 을 상속한다   
> 따라서 collection의 map과 같은 메소드에 사용가능한것이다.

## 2.2 리플렉션을 사용한 객체 직렬화 구현

우선 제이키드의 직렬화 함수 선언을 살펴보자.
```kotlin
fun serialize(obj:Any) : String
```
이 함수는 객체를 받아서 그 객체에 대한 JSON 표현을 문자열로 돌려준다.
이 함수는 객체의 프로퍼티와 값을 직렬화하면서 StringBuilder 객체 뒤에 직렬화한 문자열을 추가한다.   
이 append 호출을 더 갈결하게 수행하기 위해 직렬화 기능을 StringBuilder의 확장 함수로 구현한다.   

이렇게 하면 별도로 StringBuilder 객체를 지정하지 않아도 append 메소드를 편하게 사용할 수 있다.

```kotlin
private fun StringBuilder.serializeObject(x: Any){
    append(...)
}
``` 

함수 파라미터를 확장 함수의 수신 객체로 바꾸는 방식은 코틀린 코드에서 흔히 사용하는 패턴이다.
serializeObject는 StringBuilder API를 확장하지 않는다.   
serializeObject의 용도는 이 모듈을 벗어나면 쓸모가 없으므로 private로 가시성을 지정한다.   
이를 통해 코드 블록에서 주로 사용하는 객체가 어떤 것인지 명확히 보여주고, 그 객체를 더 쉽게 다룬다.   

```kotlin
fun serialize(obj:Any) : String = buildString{
    serializeObject(obj)
}
```

이렇게 확장 함수를 정의하면 serialize는 대부분 작업을 serializeObject에 위임한다. 
게다가 확장 함수로 지정되었으므로 this 와같은 필요없는 접근자를 사용할 필요가 없어진다.  

> buildString은 내부적으로 StringBuilder를 생성해서 인자로 받은 람다에 넘긴다.   
> 람다 안에서는 StringBuilder 인스턴스를 this로 사용할 수 있다. 
> StringBuilder의 호출은 . 없이 바로 수행할 수 있다.   
> 이 코드는 람다 본문에서 serializeObject(obj)를 호출해서 직렬화한 결과를 StringBuilder에 추가한다.
   
### JSON으로 직렬화
기본적으로 직렬화 함수는 객체의 모든 프로퍼티를 직렬화한다.
1. 원시 타입이나 문자열은 적절히 JSON 수, 불리언, 문자열 값 등으로 변환된다.
2. 컬렉션은 JSON 배열로 직렬화된다.
3. 원시 타입이나 문자열, 컬렉션이 아닌 다른 타입인 프로퍼티는 중첩된 JSON 객체로 직렬화된다.   

```kotlin
private fun StringBuilder.serializeObject(obj:Any){
    val kClass = obj.javaClass.kotlin
    val properties = kClass.memberProperties
    
    properties.joinToStringBuilder(
        this, prefix="{", postfix="}"){ prop ->
            serializeString(prop.name)
            append(": ")
            serializePropertyValue(prop.get(obj))    
        }
}
```

이러한 함수의 구현은 명확하다. 클래스의 각 프로퍼티를 차례로 직렬화한다.
결과 JSON은 {prop1:value1, prop2:value2}와 같은 형태이다.   

1. joinToStringBuilder 함수는 프로퍼티를 ,로 분리해준다.
2. serializeString 함수는 JSOn 명세에 따라 특수 문자를 이스케이프한다.   
3. serializePropertyValue 함수는 어떤 값이 원시타입, 문자열, 컬렉션, 중첩된 객체 중 
어떤 것인지 판단하고 그에 따라 값을 적절히 직렬화한다.

앞 단계에서 KProperty 인스턴스의 값을 얻는 방법인 get 메소드에 대해 설명했다.   
앞 절의 예제에서는 KProperty1<Person, Int> 타입인 Person::age 프로퍼티를 처리했기 때문에    
컴파일러가 수신 객체와 프로퍼티 값의 타입을 정확히 알 수 있었다.   

하지만 클래스에 정의된 모든 프로퍼티를 열거하기 때문에 정확히 각 프로퍼티가 어떤 타입인지 모른다.   
따라서 prop 변수의 타입은 KProperty1<Any, *> 이며,    
prop.get(obj) 메소드 호출은 Any 타입을 반환한다.

이 경우 수신 객체 타입을 컴파일 시점에 검사할 방법이 없다.   
하지만 이 코드에서는 어떤 프로퍼티의 get에 넘기는 객체가 바로   
그 프로퍼티를 얻어온 객체(obj)이기 때문에 항상 프로퍼티 값이 제대로 반환된다.   

## 2.3 애노테이션을 활용한 직렬화 제어

### @JsonExclude
어떤 프로퍼티를 직렬화에서 제외하고 싶을 때 이 애노테이션을 사용한다.   
serializeObject 함수를 어떻게 수정해야 이 애노테이션을 지원할 수 있을까?

클래스의 모든 멤버 프로퍼티를 가져오기 위해 KClass 인스턴스 memberProperties 프로퍼티를 사용할 수 있다.
하지만 @JsonExclude 애노테이션이 붙은 프로퍼티를 제외해야 하므로 문제가 약간 복잡하다.   

KAnnotatedElement 인터페이스에는 annotations 프로퍼티가 있다.   
annotations는 소스코드상에서 해당 요소에 적용된 모든 애노테이션 인스턴의 컬렉션이다.   

> KPropert는 KAnnotatedElement를 확장하므로 property.annotations를 통해    
> 모든 애노테이션을 얻을 수 있다.

특정한 애노테이션을 찾을 때는 findAnnotation이라는 함수가 쓸모 있다.
```kotlin
inline fun <reified T> KAnnotatedElement.findAnnotation() : T?
    = annotations.filterIsInstance<T>().firstOrNull()
```
이 함수는 인자로 전달받은 타입에 해당하는 애노테이션이 있으면 그 애노테이션을 반환한다.   
이제 findAnnotation을 표준 라이브러리 함수인 filter와 함깨 사용하면    
@JsonExclude로 애노테이션된 프로퍼티를 없앨 수 있다.

```kotlin
val properties = kClass.memberProperties.filter{it.findAnnotation<JsonExclude>()==null}
``` 

### @JsonName
이 경우 애노테이션의 존재 여부뿐 아니라 애노테이션에 전달한 인자도 알아야 한다.   
@JsonName의 인자는 프로퍼티를 직렬화해서 JSON에 넣을 떄 사용할 이름이다.   

```kotlin
val jsonNameAnn = prop.findAnnotation<JsonName>()
val propName = jsonNameAnn?.name?:prop.name
```

프로퍼티에 @JsonName 애노테이션이 없다면 jsonNameAnn이 널이다.   
그런 경우 여전히 prop.name을 JSON의 프로퍼티 이름으로 사용한다.   
프로퍼티에 애노테이션이 있다면 애노테이션이 지정하는 이름을 대신 사용한다.

```kotlin
private fun StringBuilder.serializeObject(obj:Any){
    obj.javaClass.kotlin.memberProperties
            .filter{it.findAnnotation<JsonExclude>()==null}
            .joinToStringBuilder(this, prefix = "{", postfix="}"){
                serializeProperty(it, obj)
            }
}
```

이 코드는 @JsonExclude로 애노테이션한 프로퍼티를 제외한다. 
또한 프로퍼티 직렬화와 관련된 로직을 serializeProperty라는 확장 함수로 분리한다.

```kotlin
private fun StringBuilder.serializeProperty(prop:KProperty1<Any,*>, obj:Any){
    val jsonNameAnn = prop.findAnnotation<JsonName>()
    val propName = jsonNameAnn?.name?:prop.name
    serializeString(propName)
    append(": ")
    serializePropertyValue(prop.get(obj))
}
```

serializeProperty는 앞서 설명한 것처럼 @JsonName에 따라 프로퍼티 이름을 처리한다.

### @CustomSerializer
이 구현은 getSerializer라는 함수에 기초한다.   
getSerializer는 @CustomSerializer를 통해 등록한 ValueSerializer 인스턴스를 반환한다.   
예를 들어 Person 클래스를 다음과 같이 정의하고    
birthDate 프로퍼티를 직렬화하면서 getSerializer()를 호출하면 DateSerializer 인스턴스를 얻을 수 있다.   

```kotlin
data class Person(
    val name: String,
    @CustomSerializer(DateSerizer::class) val birthDate: Date
)

annotation class CustomSerializer{
    val serializerClass : KClass<out ValueSerializer<*>>
}
```

getSerializer 구현은 다음과 같다.

```kotlin
fun KProperty<*>.getSerializer() : ValueSerializer<Any?>?{
    val customSerializerAnn = findAnnotation<CustomSerializer>() ?: return null
    val serializerClass = customSerializerAnn.serializerClass
    val valueSerializer = serializerClass.objectInstance ?: serializerClass.createInstance()

    @Suppress("UNCHECKED_CAST")
    return valueSerializer as ValueSerializer<Any?>
}
```

getSerializer가 주로 다루는 객체가 KProperty 인스턴스이기 때문에 확장함수로 정의한다.   
getSerializer는 findAnnotation 함수를 호출해서 @CustomSerializer 애노테이션이 있는지 찾는다.   
@CustomSerializer 애노테이션이 있다면 custom 직렬화기를 사용해야 하는 클래스이다.   

클래스와 객체는 모두 KCLass 클래스로 표현된다. 다만 객체에는 object 선언에 의해 생성된   
싱글턴을 가리키는 objectInstance라는 프로퍼티가 있다는 것이 클래스와 다른 점이다.

예를 들어 DateSerializer를 object로 선언한 경우에는 objectInstance 프로퍼티에   
DateSerializer의 싱글턴 인스턴스가 포함되어 있다.   
따라서 그 싱글턴 인스턴스를 사용해 모든 객체를 직렬화하면 되므로 crateInstance를 호출할 필요가 없다.   

하지만 KClass가 일반 클래스를 표현한다면 createInstance를 호출해 새 인스턴스를 생성해야 한다.   
createInstance 함수는 java.lang.Class.newInstance아 비슷하다.   

```kotlin
private fun StringBuilder.serializeProperty(prop:KProperty1<Any,*>, obj:Any){
    val jsonNameAnn = prop.findAnnotation<JsonName>()
    val propName = jsonNameAnn?.name?:prop.name
    serializeString(propName)
    append(": ")
    val value = prop.get(obj)
    val jsonValue = prop.getSerializer()?.toJsonVale(value) ?: value
    serializePropertyValue(prop.get(obj))
}
``` 

serializeProperty는 커스텀 직렬화기의 toJsonValue 함수를 호출해서 프로퍼티 값을 JSON 형식으로 변환한다.    
어떤 프로퍼티에 커스텀 직렬화기가 지정돼 있지 않다면 그냥 프로퍼티 값을 사용한다.

## 2.5 역직렬화 단계 : callBy(), 리플렉션을 사용해 객체 만들기

   

