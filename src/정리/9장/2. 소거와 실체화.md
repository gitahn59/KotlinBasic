# 2. 실행 시 제네릭스의 동작 : 소거된 타입 파라미터와 실체화된 타입 파라미터

JVM은 제네릭스는 보통 타입 소거를 사용해 구현된다.
이는 실행 시점에 제네릭 클래스의 인스턴스에 타입 인자 정보가 들어있지 않다는 뜻이다.

코틀린의 타입 소거가 실용적인 면에서 어떤 영향을 끼치는지 살펴보고
함수를 inline으로 선언함으로써 이런 제약을 어떻게 우회할 수 있는지 살펴본다.

함수를 inline으로 만들면 타입 인자가 지워지지 않게 할 수 있다.(이를 실체화라고 한다)   
실체화한 타입 파라미터에 대해 자세히 다루고 
실체화한 타입 파라미터가 유용한 이유를 에제를 통해 다룬다.

## 2.1 실행 시점의 제네릭 : 타입 검사와 캐스트 
자바와 마찬가지로 코틀린 제네릭 타입 인자 정보는 런타임에 지워진다.
이는 제네릭 클래스 인스턴스가 그 인스턴스를 생성할 때 쓰인 
타입 인자에 대한 정보를 유지하지 않는다는 뜻이다.

List<String> 이라고 변수를 선언했더라도 
실행 시점에는 그 객체를 오직 List로만 볼 수 있다.
그 List 객체가 어떤 타입의 원소를 저장하는지 실행 시점에는 알 수 없다.   
따라서 List<String> 이나 List<Int> 나 모두 List 이다.

컴파일러는 두 리스트를 서로 다른 타입으로 인식하지만 
실행 시점에 그 둘은 완전히 같은 타입의 객체다.

그럼에도 보통 List<String> 에는 문자열만 들어있고, List<Int> 에는 정수만 들어있다고
가정할 수 있는데 이는 컴파일러가 타입 인자를 알고 올바른 타입의 값만
각 리스트에 넣도록 보장해주기 때문이다.

### 타입 소거로 인해 생기는 한계  

```kotlin
fun <T> printList(list: List<T>) {
    when (list) {
        // T에 들어오는 Generic은 런타임에서 실행되기 전 지워지기 때문에 판단할 수 없다
        is List<String> -> println("This is a list of Strings")
        is List<Integer> -> println("This is a list of Integers")
        // 따라서 Cannot check for instance of erased type 에러가 발생한다
    }
}
```
타입 인자를 따로 저장하지 않기 때문에 실행 시점에 타입 인자를 검사할 수 없다.   
어떤 리스트가 문자열 리스트인지 다른 리스트인지 실행 시점에 검사할 수 없다.

실행 시점에 어떤 값이 List인지 여부는 확실히 알아낼 수 있다.
따라서 저장해야 하는 타입 정보의 크기가 줄어들어서 전반적인
메모리 사용량이 줄어든다는 제네렉 타입 소거 나름의 장점이 있다.

코틀린에서는 타입 인자를 명시하지 않고 제네릭 타입을 사용할 수 없다.
그렇다면 어떤 값이 집합이나 맵이 아니라 리스트라는 사일을 어떻게 확인할 수 있을까?

```kotlin
fun <T> printList(list: List<T>) {
    if (list is ArrayList<*>){
        
    }
}
```
리스트의 타입인자 자리에 * 를 집어넣으면 된다. 인자가 여러 개라면 여러 * 를 집어넣으면 된다.
> * 는 스타 프러덕션이라고 한다

as 나 as? 캐스팅에도 여전히 제네릭 타입으 사용할 수 있다. 하지만 기저 클래스는
같지만 타입 인자가 다른 타입으로 캐스팅해도 여전히 캐스팅에 성공한다는 점을
조심해야 한다. 실행 시점에는 제네릭 타입의 타입 인자를 알 수 없으므로
캐스팅은 항상 성공한다. 따라서 컴파일러가 unchecked cast라는 경고를 보여준다.   

```kotlin
fun printSum(c:Collection<*>){
    // unchecked cast 경고가 발생하지만 컴파일 가능하다
    val intList = c as? List<Int> ?: throw IllegalArgumentException("List<Int> is expected")
    println(intList.sum())
}
```

> 제네릭의 타입 인자가 소거 되는것이다. list / map / set 등의 타입이 사라지는 것이 아니다.

```kotlin
fun printSum(c:Collection<Int>){
    if(c is List<Int>) {
        println(c.sum())
    }
}
```

위 예제에서는 컴파일 시점에 c컬렉션이 Int 값을 저장한다는 사실이 알려져 있다.
따라서 c가 List<Int>인지 검사가 가능하다.

## 2.2 실체화한 타입 파라미터를 사용한 함수 선언
코틀린은 제네릭 함수의 본문에서 그 함수의 타입 인자를 검사할 수 있는 특별한 기능을 제공하지 않는다.   
하지만 inline 함수 안에서는 타입 인자를 사용할 수 있다.   

제네릭 타입의 타입 인자 정보는 실행 시점에는 지워진다. 따라서 제네릭 클래스의 인스턴스가 있어도
그 인스턴스를 만들 때 사용한 타입 인자를 알아낼 방법이 없다.

```kotlin
fun <T> isA(value : Any) = value is T
// Cannot check for instance of erased type : Tq
```

제네릭 함수의 타입 인자도 마찬가지다. 
제네릭 함수가 호출되도 그 함수의 본문에서는 호출 시 쓰인 타입 인자를 알 수 없다.

> 인라인 함수의 타입 파라미터는 실체화되므로 실행 시점에 인라인 함수의 타입 인자를 알 수 있다.

```kotlin
// reify : 구체화하다
inline fun <reified T> isA(value : Any) = value is T
```

함수를 인라인 함수로 바꾸고 타입인자를 reified로 지정하면 
함수 호출이 본문으로 대체되기 때문에 T의 타입을 알 수 있고 실행 시점에 검사에 사용할 수 있다.

이러한 기능을 사용하면 리스트에서 특정한 타입의 원소만 골라낼 수 있다.
```kotlin
val items = listOf("one", 2, "three")
println(items.filterIsInstance<String>())
// ["one", "three"] 
```
filterIsInstance의 타입 인자로 String을 지정함으로써 문자열만 필요하다는 사실을 알린다.
여기서는 타입인자를 실행 시점에 알 수 있고 함수는 그 타입 인자를 사용해 리스트의 
원소 중에서 타입 인자와 일치하는 원소만을 추출할 수 있다.

> 인라인 함수에서만 실체화한 타입 인자를 쓸 수 있는 이유   
> 실체화한 타입 인자는 어떻게 작동하는 걸까? 왜 일반 함수에서는 element is T를 사용할 수 없을까?   
> 컴파일러는 인라인 함수의 본문을 그 함수가 호출되는 모든 지점에 삽입한다.
> 컴파일러는 실체화한 타입 인자를 사용해 정확한 타입 인자를 알 수 있다.
> 따라서 컴파일러는 타입 인자로 쓰인 구체적인 클래스를 참조하는 바이트코드를 생성해 삽입할 수 있다.

> 타입 파라미터가 아니라 구체적인 타입을 사용하므로 인라이닝된 코드는 타입 소거의 영향을 안받는다.
> 자바 코드에서는 reified 타입 파라미터를 사용하는 inline 함수를 호출할 수 없다.
> 자바에서는 코틀린의 인라인 함수를 보통 함수처럼 호출한다.

인라인 함수에는 실체화한 타입 파라미터가 여러개 있거나 실체화한 타입과 하지 않은 파라미터가
섞여 있을 수 있다. 람다를 파라미터로 받지 않지만 filterIsInstance를 인라인 함수로 정의했다는 점에 유의하자.

파라미터 중에 함수 타입인 파라미터가 있고 그 파라미터에 해당하는 인자를 함께 인라이닝함으로써
얻는 이익이 큰 경우엠반 인라인 함수로 만들라고 했다.

하지만 이 경우 inline으로 만드는 이유가 성능 향상이 아니라 실체화를 얻기 위함이다.   
성능을 좋게 하려면 인라인 함수의 크기를 게쏙 확인해야 한다. 
함수가 커지면 실체화한 타입에 의존하지 않는 부분을 따로 뽑아내는 편이 낫다.

## 2.3 실체화한 타입 파라미터로 클래스 참조 대신 

코틀린의 어댑터가 java.lang.Class 타입을 인자로 받는경우 실체화한 타입 파라미터를 자주 사용한다. 
java.lang.Class를 사용하는 API의 예로는 JDK의 ServiceLoader가 있다.

ServiceLoader는 어떤 추상 클래스나 인터페이스를 표현하는 java.lang.Class를 받아서
그 클래스나 인스턴스를 구현한 인스턴스를 반환한다.
실체화한 타입 파라미터를 활용해 이런 API를 쉽게 호출할 수 있게 만들어 보자.

표준 자바 API인 ServiceLoader를 사용해 서비스를 읽어 들이려면 다음과 같이 호출한다.
```kotlin
val serviceImpl = ServiceLoader.load(Service::class.java)
```
::class.java 구문은 코틀린 클래스에 대응하는 java.lang.Class 참조를 얻는다.   
이러한 구문은 inline 과 reified를 사용해 가독성 좋은 함수로 래핑할 수 있다.

```kotlin
inline fun <reified T> loadService(){
    return ServiceLoader.load(T::class.java)
}

val serviceImpl = loadService<Service>()
```

일반 클래스에 사용할 수 있는 ::class.java 구문을 이 경우에도 사용할 수 있다.
이를 통해 타입 파라미터로 지정된 클래스에 따른 java.lang.Class를 얻을 수 있고,
클래스 참조를 보통 때와 마찬가지로 사용할 수 있다.

## 2.4 실체화한 타입 파라미터의 제약
실체화한 타입 파라미터는 유용한 도구지만 몇 가지 제약이 있다.

1. 타입 검사와 캐스팅(is, !is, as, as?)
2. 코틀린 리플렉션 API(::class)
3. 코틀린 타입에 대응하는 java.Lang.class 얻기(::class.java)
4. 다른 함수를 호출할 때 타입 인자로 사용

하지만 다음과 같은 일은 할 수 없다.
1. 타입 파라미터 클래스의 인스턴스 생성
2. 타입 파라미터 클래스의 동반 객체 메소드 호출
3. 실체화한 타입 파라미터를 요구하는 함수를 호출하면서 
   실체화하지 않은 타입 파라미터로 받은 타입을 타입 인자로 넘기기
4. 클래스, 프로퍼티, 인라인 함수가 아닌 함수의 타입 파라미터를 reified로 지정