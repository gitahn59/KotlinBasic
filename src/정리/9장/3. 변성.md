# 3. 변성 : 제네릭과 하위 타입

변성의 개념은 List<String> 과 List<Any> 와 같이 기저 타입이 같고 타입 인자가
다른 여러 타입이 서로 어떤 관계가 있는지 설명하는 개념이다.
일반적으로 이런 관계가 왜 중요한지 먼저 설명하고 코틀린에서 변성을 어떻게 표시하는지 알아본다.

## 3.1 변성이 있는 이유 : 인자를 함수에 넘기기 위함
List<Any> 타입의 파라미터를 받는 함수에 List<String> 을 넘기면 안전할까?
String 클래스는 Any를 확장하므로 Any 타입 값을 파라미터로 받는 함수에 List<String>을
넘겨도 절대로 안전하다.

하지만 Any와 String이 List 인터페이스의 타입 인자로 들어있는 경우 안정성을 보장할 수 없다.

```kotlin
fun addAnswer(list:MutableList<Any>){
    list.add(42)
}

val strings = mutableListOf("abc","bac")
addAnswer(strings) // 이 라인이 정상적으로 작동한다면
println(strings.maxBy{it.length})
// ClassCastException : Integer cannot be cast to String
```
따라서 이 함수 호출은 컴파일되지 않는다.
어떤 함수가 리스트의 원소를 추가하거나 변경한다면 타입 불일치가 발생할 수 있다.
원소 추가나 변경이 없는 경우에는 List<String>을 List<Any> 대신 넘겨도 안전하다.
코틀린에서는 리스트의 변경 가능성에 따라 적절한 인터페이스를 선택하면
안전하지 못한 함수 호출을 막을 수 있다.
함수가 읽기 전용 리스트를 받는다면 더 구체적인 타입의 원소를 갖는 리스트를
그 함수에 넘길 수 있다. 하지만 변경 가능하다면 그럴 수 없다.

## 3.2 클래스, 타입, 하위 타입
> 변수의 타입은 그 변수에 담을 수 있는 값의 집합을 지정한다.

제네릭 클래스가 아닌 클래스에서는 클래스 이름을 바로 타입으로 쓸 수 있다.
예를 들어 var x : String 이라고 쓰면  String 클래스의 인스턴스를 저장하는 변수를 정의한다.

하지만 var x:String? 처럼 널이 될 수 있는 타입에도 쓸 수 있다.
이는 모든 코틀린 클래스가 적어도 둘 이상의 타입을 구성할 수 있다는 뜻이다.

제네릭 클래스에서는 상황이 더 복잡하다. 올바른 타입을 얻으려면 제네틱 타입의 파라미터를
구체적인 타입 인자로 바꾸어야 한다. 제네릭 클래스는 무수히 많은 타입을 만들 수 있다.

타입 사이의 관계를 논하기 위해 하위 타입이라는 개념을 알아야 한다.
> 어떤 타입 A의 값이 필요한 모든 장소에 어떤 타입 B의 값을 넣어도 문제가 없다면   
> 타입 B는 타입 A의 하위 타입이다.

> Int는 Number의 하위 타입이지만 String의 하위 타입이 아니다.   
> 모든 타입은 자기 자신의 하위 타입이다.

상위 타입은 하위 타입의 반대다. A 타입이 B 타입의 하위 타입이라면 B 타입은 A 타입의 상위 타입이다.   
컴파일러는 변수 대입이나 함수 인자 전달 시 하위 타입 검사를 매번 수행한다.   

어떤 값의 타입이 변수 타입의 하위 타입인 경우에만 값을 변수에 대입하게 허용한다.
간단한 경우 하위 타입은 하위 클래스와 근본적으로 같다.
Int 클래스는 Number의 하위 클래스이므로 Int는 Number의 하위 타입이다.

String은 CharSequence의 하위 타입인 것처럼 어떤 인터페이스를 구현하는 클래스의 타입은
그 인터페이스 타입의 하위 타입이다.

널이 될 수 있는 타입은 하위 타입과 하위 클래스가 같지 않은 경우를 보여준다.
항상 널이 될 수 없는 타입의 값을 널이 될 수 있는 타입의 변수에 저장할 수 있다. 

> 널이 될 수 없는 타입은 널이 될 수 있는 타입의 하위 타입이다.   
> 하지만 두 타입 모두 같은 클래스에 해당한다.

제네릭 타입에 대해 이야기할 때 특히 하위 클래스와 하위 타입의 차이가 중요하다.

List<String> 타입의 값을 List<Any> 를 파라미터로 받는 함수에 전달해도 괜찮은가?
=> List<String>은 List<Any>의 하위 타입인가?

이전 예시에서 MutableList<String>을 MutableList<Any> 의 하위 타입으로 다루면
문제가 발생한다. MutableList<Any> 도 MutableList<String>의 하위 타입이 아니다.

제네릭 타입을 인스턴스화할 때 타입 인자로 서로 다른 타입이 들어가서
인스턴스 타입 사이의 하위 타입 관계가 성립하지 않으면 
그 제네릭 타입을 무공변(invariant)이라고 말한다.

MutableList는 타입인자가 다르면 그 둘은 항상 서로 하위 타입이 아니다.   
> 자바에서는 모든 클래스가 무공변이다.

코틀린의 List 인터페이스는 읽기 전용 컬렉션을 표현한다.
이 경우 A가 B의 하위 타입이면 List<A>는 List<B>의 하위 타입이다.
이런 경우를 공변적(convariant) 라고 말한다.

## 3.3 공병성 : 하위 타입 관계를 유지
코틀린에서 제네릭 클래스가 타입 파라미터에 대해 공변적임을 표시하려면    
타입 파라미터 앞에 out을 넣어야 한다.
```kotlin
interface Producer<out T>{
    fun produce(): T
}
```

클래스의 타입 파라미터를 공변적으로 만들면 파라미터의 타입과
타입 인자의 타입이 정확히 일치하지 않더라도 
그 클래스의 인스턴스를 함수 인자나 반환 값으로 사용할 수 있다.

모든 클래스를 공변적으로 만들 수는 없다.   
공변적으로 만들면 안전하지 못한 클래스도 있다.    
타입 파라미터를 공변적으로 지정하면 클래스 내부에서 그 파라미터를 사용하는 방법을 제한한다.

타입 안정성을 보장하기 위해 공변적 파라미터는 항상 아웃 위치에만 있어야 한다.
이는 클래스가 T 타입의 값을 생산할 수 있지만 T 타입의 값을 소비할 수는 없다는 뜻이다.

클래스 멤버를 선언할 때 타입 파라미터를 사용할 수 있는 지점은 모두 인과 아웃 위치로 나뉜다.
T가 함수의 반환 타입에 쓰인다면 T는 아웃 위치에 있다. 그 함수는 T 타입의 값을 생산한다.

클래스 타입 파라미터 T 앞에 out 키워드를 붙이면 그 타입인자는 공변성을 가지게 된다.    
그러면 T를 사용하는 메소드가 아웃(리턴) 위치에서만 타입 인자를 사용할 수 있다.
out 키워드는 T로 인해 생기는 하위 타입 관계의 타입 안정성을 보장한다.

List<T> 는 읽기 전용이다.    
따라서 그 안에는 T 타입의 원소를 반환하는 get 메소드는 있지만    
리스트에 T 타입의 값을 추가하거나 리스트에 있는 기존 값을 변경하는 메소드는 없다.   
따라서 List는 T에 대해 공변적이다.

MutableList<T>는 타입 파라미터 T에 대해 공변적인 클래스로 선언할 수는 없다.
MutableList<T>에는 T를 인자로 받아서 그 타입의 값을 반환하는 메소드가 있기 때문이다.

> 생성자 파라미터는 인이나 아웃 어느쪽도 아니다.
> 타입 파라미터가 out이라 해도 그 타입을 여전히 생성자 파라미터 선언에 사용할 수 있다.   
> 생성자는 나중에 호출할 수 있는 메소드가 아니므로 위험할 여지가 없다.

변성은 코드에서 메소드를 호출할 수 없도록 만들어 
제네릭 타입의 인스턴스 역할을 하는 클래스 인스턴스를 잘못 사용하는 일이 없게 방지한다.

하지만 val 이나 var 키워드를 생성자 파라미터에 적는다면 게터나 세터를 정의하는 것과 같다.
따라서 읽기 전용 프로퍼티는 아웃 위치, 변경 가능 프로퍼티는 아웃과 인 위치 모두에 해당한다.

> 이러한 규칙은 오직 외부에서 볼 수 있는 (public, protected, internal) 
> 클래스 PI에만 적용된다.    
> 비공개 메소드의 파라미터는 인도 아니고 아웃도 아닌 이치다.
> 클래스 내부 구현에는 적용되지 않는다.  

## 3.4 반공변성 : 뒤집힌 하위 타입 관계
반공변성은 공변성의 반대이다. 반공변 클래스의 하위 타입 관계는 공변 클래스의 경우와 반대다.

예를 들어 Comparator 인터페이스를 보자. 이 인터페이스에는 compare라는 메소드가 있다.
이 메소드는 주어진 두 객체를 서로 비교한다.

```kotlin
interface Comparator<in T>{
    fun compare(e1:T, e2: T) : Int{...}
}
```
이 인터페이스의 메소드는 T 타입의 값을 소비하기만 한다.

> 이는 T가 인 위치에서만 사용된다는 뜻이다.      
> 따라서 T 앞에는 in 키워드가 붙어야만 한다.   

어떤 타입에 대해 Comparator를 구현하면 그 타입의 하위 타입에 속하는 모든 값을 비교할 수 있다.
예를 들어 Comparator<Any> 가 있다면 이를 사용해 모든 타입의 값을 비교할 수 있다.

```kotlin
val anyComparator = Comparator<Any> { e1, e2 -> e1.hashCode() - e2.hashCode() }
val strings = listOf("abc", "def", "AA")
val rst = strings.sortedWith(anyComparator)
```

sortedWith 함수는 Comparator<String> 을 요구하므로, String 보다 더 일반적인 타입을 비교할 수 있는
Comparator를 sortedWith에 넘기는 것은 안전하다.
어떤 타입의 객체를 Comparator로 비교해야 한다면 그 타입이나 그 타입의 조상 타입을 비교할 수 있는 
Comparator를 사용할 수 있다.

이는 Comparator<Any> 가 Comparator<String> 의 하위 타입이라는 뜻이다.
여기서 Any는 String의 상위 타입이다. 따라서 서로 타른 타입 인자에 대해
Comparator의 하위 타입 관계는 타입 인자의 하위 타입 관계와는 정반대 방향이다.

타입 B가 타입 A의 하위 타입인 경우 Consumer<A> 가 Consumer<B>의 하위 타입인 관계가 성립하면
제네릭 클래스 Consumer<T>는 타입 인자 T에 대해 반공변이다.

> A와 B의 위치가 서로 뒤바뀐다.

Consumer<Animal>은 Consumer<Car>의 하위 타입이다.

in이라는 키워드는 그 키워드가 붙은 타입이 이 클래스의 메소드 안으로 전달돼
메소드에 의해 소비된다는 뜻이다.    
공변성의 경우와 마찬가지로 타입 파라미터의 사용을 제한함으로써 특정 하위 타입 관계가 된다.   
in 키워드를 타입 인자에 붙이면 그 타입 인자를 오직 인 위치에서만 사용할 수 있게된다.

> 공변성
> Producer<out T> / 타입 인자의 하위 타입 관계가 제네릭 타입에서도 유지 /   
> Producer<Cat> 은 Producer<Animal>의 하위 타입 / T를 아웃 위치에서만 사용

> 반공변성   
> Consumer<in T> / 타입인자의 하위 타입 관계가 제네릭 타입에서 뒤집힘 /      
> Consumer<Animal>은 Consumer<Cat>의 하위 타입 / T를 인 위치에서만 사용   

> 무공변성   
> 하위 타입 관계가 성립하지 않음 / T를 아무 위치에서나 사용

클래스나 인터페이스가 어떤 타입 파라피터에 대해서는 공변적이면서 다른 타입 파라미터에 대해서는
반공변적일 수 도 있다. Function 인터페이스가 그렇다.

```kotlin
interface Function1<in P, out R>{  
    operator fun invoke(p:P):R
}
```

코틀린 표기에서 (P) -> R 은 Function1<P,R>을 보기 쉽게 적은 것이다.
오직 인 위치 / 오직 아웃 위치에서 사용된다는 사실과 각각 in / out 키워드가 붙어있다.

예를 들어 동물을 인자로 받아서 정수를 반환하는 람다를 고양이에게 번호를 붙이는 고차 함수에 사용할 수 있다.
```kotlin
fun enumerateCats(f: (Cat) -> Number){}
fun Animal.getIndex() : Int = ...  
// (Animal) -> Int 와 동치 

enumerateCats(Animal::getIndex)
```
Animal 과 Cat이 in 위치에서만 사용된다. 따라서 반공변성을 가지게 되고
Cat의 상위 타입인 Animal 이 사용되는 람다를 사용할 수 있게되는 것이다.

크래스 정의에 변성을 직접 기술하면 그 클래스를 사용하는 모든 장소에 그 변성이 적용된다.
자바는 이를 지원하지 않는다. 대신 클래스를 사용하는 위치에서 와일드카드를 사용해
그때그때 변성을 지정한다.

## 3.5 사용 지점 변성 : 타입이 언그되는 지점에서 변성 지정
클래스를 선언하면서 변성을 지정하면 그 클래스를 사용하는 모든 장소에 변성 지정자가 영향을 미친다.
> 이런 방식을 선언 지점 변성이라 부른다.   

자바는 와일드카드 타입(? extends나 ? super) 으로 변성을 다룬다.
자바에서는 타입 파라미터가 있는 타입을 사용할 때마다 해당 타입 파라미터를 
하위 타입이나 상위 타입 중 어떤 타입으로 대치할 수 있는지 명시해야 한다.
> 이런 방식을 사용 지점 변성이라 부른다.

### 코틀린 선언 지점 변성과 자바 와일드카드 비교
선언 지점 변성을 사용하면 변성 변경자를 단 한 번만 표시하고 클래스를 쓰는 쪽에서는 변성에 신경 쓸 필요없다.
자바에서 사용자의 예상대로 동작하는 API를 만들기 위해 라이브러리 개발자는 항상
Function<? super T, ? extends R> 처럼 와일드카드를 사용해야 한다.

자바 8 표준 라이브러리 소스를 보면 Function 인터페이스를 사용하는 모든 위치에서 와일드카드를 볼 수 있다.   
ex)   
```java
public interface Stream{
    <R> Stream <R> map(Function<? super T, ? extends R> mapper);
}
```
클래스 선언 지점에서 변성을 한 번만 지정하면 훨씬 더 간결하고 우아한 코드를 작성할 수 있다.

코틀린도 사용 지점 변성을 지원한다. 따라서 클래스 안에서 어떤 타입 파라미터가 공변적이거나 반공변적인지
선언할 수 없는 경우에도 특정 타입 파라미터가 나타나는 지점에서 변성을 정할 수 있다.

MutableList와 같은 상당수의 인터페이스는    
타입 파라미터로 지정된 타입을 소비하는 동시에 생산훌 수 있기 때문에 무공변적이다.
하지만 그런 인터페이스 타입의 변수가 한 함수 안에서 생산자나 소비자 중 단 한가지 역할만 담당하는 경우가 잦다.

```kotlin
fun <T> copyData(source: MutableList<T>, destination: MutableList<T>){
    for(item in source){
        destination.add(item)
    }
}
```   

이 함수는 컬렉션의 원소를 다른 컬렉션으로 복사한다.  
두 컬렉션 모두 무공변 타입이지만 원본 컬렉션에서는 읽기만 하고 대상 컬렉션에는 쓰기만 한다.   
이 경우 두 컬렉션의 원소 타입이 정확하게 일치할 필요가 없다.

이 함수가 여러 다른 리스트 타입에 대해 작동하게 만드려면 두 번째 제네릭 타입 파라미터를 도입할 수 있다.
```kotlin
fun <T:R, R> copyData(source: MutableList<T>, destination: MutableList<R>){
    for(item in source){
        destination.add(item)
    }
}
```
source의 원소 타입은 R의 하위 타입이어야 한다.
두 타입 파라미터는 원본과 대상 리스트의 원소 타입을 표현한다.     
한 리스트에서 다른 리스트로 원소를 복사할 수 있으려면 원본 리스트의 원소 타입은 대상 리스트의 하위 타입이어야 한다.   

하지만 코틀린에서는 이를 더 우아하게 표현할 수 있는 방법이 있다. 함수 구현이 아웃위치(또는 인 위치)에 있는    
타입 파라미터를 사용하는 메소드만 호출한다면 그런 정보를 바탕으로    
함수 정의 시 타입 파라미터에 변성 변경자를 추가할 수 있다.   

```kotlin
fun <T> copyData(source: MutableList<out T>, destination:MutableList<T>){
    for(item in source){
        destination.add(item)
    }
}
```
타입 선언에서 타입 파라미터를 사용하는 위치라면 어디에서나 변성 변경자를 붙일 수 있다.   
파라미터 타입, 로컬 변수 타입, 함수 반환 타입 등에 타입 파라미터가 쓰이는 경우 in이나 out 변경자를 붙일 수 있다.   
이 때 타입 프로젝션이 일어난다.

즉 source를 일반적인 MutableList가 아니라 MutableList를 프로젝션을 한(제약이 생긴) 타입으로 만든다.
이 경우 copyData 함수는 MutableList의 메소드 중에서 
반환 타입으로 타입 파라미터 T를 사용하는 메소드만 사용할 수 있다.
(타입 파라미터 T를 아웃 위치에서만 사용하는 메소드만)   

컴파일러는 타입 파라미터 T를 함수 인자 타입(인 위치에 있는 타입)으로 사용하지 못하게 막는다.

프로젝션 타입의 메소드 중 일부를 호출하지 못하게 되며, 이를 호출하고 싶다면 일반 타입을 사용하면 된다.   
물론 copyData와 같은 함수를 제대로 구현하는 방법은 List<T>를 source 인자의 타입으로 정하는 것이다.   

> List에 있는 메소드만 source에 대해 사용하면 되고, List의 타입 파라미터 공변성을 List 선언에 들어있다.

List<out T> 처럼 이미 out 변경자가 지정된 타입 파라미터를 다시 out 프로젝션하는것은 의미가 없다.
컴파일러는 불필요한 프로젝션이라는 경고를 한다.

비슷한 방법으로 타입 파라미터가 쓰이는 위치 앞에 in을 붙여서 그 위치에 있는 값이 소비자 역할을 수행한다고
표시할 수 있다.
in을 붙이면 그 파라미터를 더 상위 타입으로 대치할 수 있다.

```kotlin
fun <T> copyData(source:MutableList<T>, destination:MutableList<in T>){
    for (item in source){
        destination.add(item)
    }
}
```

코틀린의 사용 지점 변성 선언은 자바의 한정 와일드카드(bounded wildcard)와 똑같다.
1. MutableList<out T>는 자바 MutableList<? extends T>와 같다.
2. MutableList<in T>는 자바 MutableList<? super T>와 같다.

## 3.6 스타 프로젝션 : 타입 인자 대신 * 사용
MutableList<*>는 MutableList<Any?>와 같지 않다.   
MutableList<Any?>는 모든 타입의 원소를 담을 수 있다는 사실을 알 수 있는 리스트다.   

반면 MutableList<*>는 어떤 정해진 구체적인 타입의 원소만을 담는 리스트지만   
그 원소의 타입을 정확히 모른다는 사실을 표현한다.

리스트의 타입이 MutableList<*>라는 말은 그 리스트가 String가 같은 구체적인 타입의
원소를 저장하기 위해 만들어진 것이라는 뜻이다.(Any는 여러가지 다 가능)

리스트의 원소 타입을 모른다고해서 아무 원소나 다 담아도 된다는 뜻은 아니다.
그 리스트에 담는 값의 타입에 따라 조건을 깰 수도 있기 때문이다.   

하지만 MutableList<*> 타입의 리스트에서 원로를 얻을 수는 있다.
그런 경우 진짜 원소 타입은 알 수 없지만 원소 탕비이 Any?의 하위 타입이라는 사실만은 분명하다.
Any?는 코틀린에서 모든 타입의 상위 타입이기 때문이다.   

컴파일러는 MutableList<*> 를 MutableList<out Any?>으로 인식한다.
어떤 리스트의 원소 타입을 모르더라도 그 리스트에서 안전하게 Any? 타입의 원소를 가져올 수는 있지만,   
타입을 모르는 리스트에 원소를 마음대로 넣을 수는 없다.

자바 와일드카드와 비교하자면 코틀린의 MyType<*>는 자바의 MyType<?>에 대응한다.

> Consumer<in T>와 같은 반공변 타입 파라미터에 대한 스타 프로덕션은 <in Nothing>와 동일하다.
> 결과적으로 그런 스타 프로젝션에서는 T가 시그니처에 들어가 있는 메소드를 호출 할 수 없다.
> 타입 파라미터가 반공변이라면 제네릭 클래스는 소비자 역할을 하는데, 우리는 T가 어떤 역할을 하는지 알 수 없다.   
> 따라서 반공변 클래스가 무언가를 소비하도록 원소를 넘겨서는 안된다.

타입 파라미터를 시그니처에서 전혀 언급하지 않거나 데이터를 읽기는 하지만 그 타입에 관심이 없는 경우
타입 인자 정보가 중요하지 않을 떄도 스타 프로젝션 구문을 사용할 수 있다.

```kotlin
fun printFirst(list: List<*>) {
    if (list.isNotEmpty()){
        println(list.first())
    }
}
```

사용 지점 변성과 마찬가지로 이런 스타 프로덕션도 우회하는 방법이 있는데, 제네릭 타입 파라미터를 도입하면 된다.
스타 프로젝션을 쓰는 쪽이 더 간결하기는 하지만 제네릭 타입 파라미터가 어떤 타입인지 알 필요가 없을 때만
스타 프로젝션을 사용할 수 있다. 스타 프로젝션을 사용할 때는 값을 만들어내는 메소드만 호출할 수 있고,
그 값의 타입에는 신경을 쓰지 말아야 한다.

### 스타프로덕션을 사용하며 빠지기 쉬운 함정
사용자 입력을 검증하기 위해 FieldValidator라는 인터페이스를 정의했다고 가정하자.
FieldValidator에는 인 위치에만 쓰이는 타입 파라미터가 있다.   
따라서 FieldValidator는 반 공변성이다.

실제로 String 타입의 필드를 검증하기 위해 Any 타입을 검증하는 FielValidator를 사용할 수 있다.

```kotlin
interface FieldValidator<in T>{
    fun validate(input: T) : Boolean
}
object DefaultStringValidator : FieldValidator<String>{
    override fun validate(input: String) = input.isNotEmpty()
}

object DefaultIntValidator : fieldValidator<Int> {
    override fun validate(input : Int) = input >= 0
}
```

검증기를 모두 제작하였으니 컨테이너에 넣고 입력 필드의 타입에 따라 사용해보자.

```kotlin
val validators = mutableMapOf<KClass<*>,FieldValidator<*>>()
validators[String::class] = DefaultStringValidator
validators[Int::class] = DefaultIntValidator

validators[String::class]!!.validate("abc") 
// Error : Out-projected type 'FieldValidator<*>' prohibits
the use of 'fun validate(input : T) : Boolean'
```

MutableList<*> 타입의 리스트에 원소를 넣으려고 했을 때 이 오류를 본적이 있다.
여기서 이 오류는 알 수 없는타입의 검증기에 구체적인 타입의 값을 넘기면 안전하지 않다는 뜻이다.

검증기를 원하는 타입으로 캐스팅하면 이런 문제를 해결할 수 있다.
하지만 그런 타입 캐스팅은 안전하지 못하고 권장하지도 않는다.
어쨋든 이번 단계에서는 타입 캐스팅을 통해 해결해보자.

```kotlin
val stringValidator = validators[String::class] as FieldValidator<String>
println(stringValidator.validate(""))
```

컴파일러는 as 로 인한 캐스팅이 위험하다고 경고한다.   
이 코드를 실행하면 타입 캐스팅 부분에서 실패하지 않고 값을 검증하는 메소드 안에서 실패한다.   
실행 시점에 모든 제네릭 타입 정보는 사라지므로 타입 캐스팅은 문제가 없고,
실제 실행 타임에 문제가 발생할 수 있다.

```kotlin
val stringValidator = validators[Int::class] as FieldValidator<String>
println(stringValidator.validate(""))
```

캐스팅 단계에서는 경고가 발생한다. 하지만 실행은 가능하고 실제 메소드를 실행하는 부분에서 실패한다.   
이제 책임이 프로그래머에게 넘어온 것이다.

이런 해법은 타입 안정성을 보장할 수도 없고 실수하기 쉽다.
따라서 한 장소에 여러 타입의 검증기를 보관할 좋은 방법을 찾아야 한다.   

이러한 해법은 똑같이 validators 맵을 사용하지만 검증기를    
등록하거나 가져오는 작업을 수행할 때 타입을 제대로 검사하게 캡슐화한다.    
이 코드도 앞의 예제와 마찬가지로 안전하지 않은 캐스팅 오류를    
컴파일 시 발생시키지만 Validator 객체가 맵에 대한 접근을 통제하기 때문에    
맵에 잘못된 값이 들어가지 못하게 막을 수 있다.

```kotlin
object Validators{
    private val validators
            = mutableMapOf<KClass<*>, FieldValidator<*>>()
    fun <T : Any> registerValidator(kClass: KClass<T>, fieldValidator : FieldValidator<T>){
        validators[kClass] = fieldValidator
    }

    @Suppress("UNCHECKED_CAST")
    operator fun<T:Any> get(kClass:KClass<T>) : FieldValidator<T> =
            validators[kClass] as? FieldValidator<T>
                    ?: throw IllegalArgumentException("No validator for ${kClass.simpleName}")
}
```
안전하지 못한 모든 로직은 클래스 내부에 감춘다. 
그리고 안전하지 못한 부분은 감춤으로써 이제는 외부에서 그 부분을 잘못 사용하는 경우를 방지할 수 있따.

Validators 객체에 있는 제네릭 메소드에서 검증기와 클래스의 타입 인자가 같기 때문에 같은 타입의 검증기만
등록할 수 있다.

```kotlin
Validators.registerValidator(String::class,DefaultStringValidator)
Validators.registerValidator(Int::class,DefaultIntValidator)

println(Validators[String::class].validate("abc"))
```

이 패턴을 모든 커스텀 제네릭 클래스를 저장할 때 사용할 수 있게 확장할 수도 있다.   
안전하지 못한 코드를 별도로 분리하면 그 코드를 잘못 사용하지 못하게 방지할 수도 있고    
안전하게 컨테이너를 사용하게 만들 수 있다.   
