# 제네릭스

- 제네릭 함수와 클래스를 정의하는 방법
- 타입 소거와 실체화한 타입 팡라미터
- 선언 지점과 사용 지점 변성

코틀린에서 제네릭 클래스와 함수를 선언하고 사용하는 개념은 자바와 비슷하다.

# 1. 제네릭 타입 파라미터
제네릭 타입의 인스턴스를 만들려면 타입 파라미터<T>에 구체적인 타입을 넣어주어야 한다.
클래스에 타입 파라미터가 여러개 있을 수도 있다. 
예를 들어 Map 클래스는 키 타입과 값 타입을 각각 파라미터로 받으므로 
Map<K,V>가 된다.

```kotlin
val people = listOf("Alan", "Bob") 
```

ListOf에 전달된 두 값이 문자열이기 때문에 컴파일러는 이 리스트가 List<String>임을
추론한다. 반면 빈 리스트를 만들어야 한다면 타입 인자를 추론할 수 없으므로
직접 타입 인자를 명시해야 한다.

```kotlin
val readers : MutableList<Stirng> = mutableListOf()
val readers = mutableListOf<String>()
```
두 방법 모두 컴파일러가 타입을 추론할 수 있도록 정보를 제공하므로 모두 가능하다.

> 자바와 달리 코틀린에서는 제네릭 타입의 타입 인자를 반드시 컴파일러가 추론할 수 있어야 한다.

## 1.1 제네릭 함수와 프로퍼티
함수를 작성할 때 모든 리스트(제네릭 리스트)를 다루는 함수를 원할 것이다.
제네릭 함수를 호출할 때는 반드시 구체적 타입으로 타입 인자를 넘겨야 한다.
컬렉션을 다루는 대부분 함수는 제네릭 함수다.

```kotlin
fun <T> List<T>.slice(indices: IntRange): List<T>
```
함수의 타입 파라미터 T가 수신 객체(확장함수의 대상)와 반환 타입에 쓰인다.
수신 객체와 반환 타입 모두 List<T>다. 
이런 함수를 구체적인 리스트에 대해 호출할 때 타입 인자를 명시적으로 지정할 수 있다.
하지만 대부분 컴파일러가 자동으로 타입 인자를추론할 수 있다.

```kotlin
val people = listOf("Alan", "Bob")
val readers = mutableListOf<String>(/*...*/)
fun <T> List<T>.filter(predicate:(T)->Boolean) : List<T>

readers.filter{it!in people}
```
람다 파라미터에 대해 자동으로 만들어진 변수 it는 타입이 T인 제네릭 타입이다.

컴파일러는 다음의 정보를 가진다.
1. filter가 List<T> 타입의 리스트에 대해 호출될 수 있다
2. filter의 수신 객체인 reader의 타입이 List<String> 이다.   
따라서 T는 String이라는 추론 정보를 가진다.

클래스나 인터페이스 안에 저으이된 메소드 / 확장함수 / 최상위 함수에서 타입 파라미터를
사용할 수 있다. 
> 게다가 확장 함수는 수신 객체의 타입에도 T를 사용할 수 있다.

제네릭 함수를 정의할 때와 마찬가지로 제네릭 확장 프로퍼티를 선언할 수 있다.
다음은 리스트의 마지막 원소 바로 앞에 있는 원소를 반환하는 혹장 프로퍼티다.

```kotlin
val <T> List<T>.penultimate:T
    get() = this[size-2]
``` 

> 일반 (혹장이 아닌) 프로퍼티는 타입 파라미터를 가질 수 없다.    
> 클래스 프로퍼티에 여러 타입의 값을 저장할 수는 없으므로 제네릭한 일반 프로퍼티는 말이 되지 않는다.
> 일반 프로퍼티를 제네릭하게 정의하면 오류가 발생한다.
> (클래스의 T가 아니라 자체적으로 타입 인자를 사용하는 경우를 말함)      
> type parameter of a property must be used in its receiver type

## 9.1.2 제네릭 클래스 선언
자바와 마찬가지로 코틀린에서도 타입 파라미터를 넣은 꺽쇠 기호(<>)를 클래스 이름 뒤에 붙이면
클래스를 제네릭하게 만들 수 있다.
타입 파라미터를 붙이고 나면 본문 안에서 타입 파라미터를 다른 일반 타입처럼 사용할 수 있다.   

### 제네릭 클래스의 확장
제네릭 클래스를 확장하는 클래스를 정의하려면 기반 타입의 제네릭 파라미터에 타입 인자를 지정해야 한다.
이떄 구체적인 타입 정보를 넘길 수 도 있고, sub 클래스가 제네릭 클래스라면 자시의 타입 인자를 넘겨도 좋다.

```kotlin
class StringList : List<String>{
    override fun get(index: Int) : String = ...
}
class ArrayList<T> : List<T>{
    override fun get(index: Int) : T = ... 
}
```

StringList는 String 타입의 원소만을 포함한다. 따라서 String을 기반 타입의 타입 인자로 지정한다.

> 하위 클래스에서 상위 클래스에 정의된 함수를 오버라이드하거나 사용하려면
타입 인자 T를 구체적 타입 String으로 치환해야 한다. 
```kotlin
fun get(Int) : T // 틀림 
fun get(Int) : String // 맞음
``` 
반면 ArrayList의 경우 자신만의 타아입 파라미터 T를 정의하면서 그 T를 기반 클래스의 타입 인자로 사용한다.
따라서 메소드를 오버라이드 할 때도 T를 사용한다.

## 1.3 타입 파라미터 제약
타입 파라미터 제약은 클래스나 함수에 사용할 수 있는 타입 인자를 제한하는 기능이다.
예를 들어 리스트에 속한 원소의 합을 구하는 sum 함수를 생각해 보자.
Int나 Double 과 같은 숫자형 클래스에는 정상적으로 동작하지만 다른 타입에는 그렇지 않다.   

타입 파라미터에 대한 상한(upper bound) 로 지정하면    
그 제네릭 타입을 인스턴스화 할 때 사용하는 타입 인자는    
반드시 그 상한 타입이거나 그 상한 타입의 하위 타입이어야 한다.   

> 조상 타입에 대한 상한을 의미한다. 확장 x   

제약을 가하려면 타입 파라미터 이름 뒤에 콜론(:)과 상한 타입을 적으면 된다.

```kotlin
fun <T:Unmber> List<T>.sum() : T
```
```java
<T extends Number> T sum(List<T> list)
```

타입 파라미터의 제약에는 여러개를 지정할 수 있다.
그 경우 where 구문을 사용한다.

```kotlin
fun <T> ensureTrailingPeriod(seq : T) 
    where T : CharSequence, T : Appendable{
    if(!seq.endsWith('.')){
        seq.append('.')
    }
}
```
이러한 제약은 T 에 들어올 수 있는 클래스가 CharSequence와 Appendable 두 가지
인터페이스를 구현해야 함을 표현한다.

## 1.4 타입 파라미터를 널이 될 수 없는 타입으로 한정
제네릭 클래스나 함수를 정의하고 그 타입을 인스턴스화 할 떄는 널이 될 수 있는 값도 사용할 수 있다.
> 아무런 상한을 정하지 않으면 기본값으로 Any? 가 설정되기 때문이다.

```kotlin
class Processor<T>{
    fun process(value:T){
        value?.toString()
    }
}
```

process 함수에는 Value 파라미터의 타입 T에는 ?가 붙어있지 않지만 실제로는 
T에 해당하는 타입 인자로 null이 될 수 있는 타입도 넘길 수 있다.

항상 널이 될 수 없는 타입만 타입 인자로 받게 하려면 타입 인자에 명시적으로
Any를 상한으로 지정해야 한다.