# Type System

### 타입 파라미터의 널 가능성
타입 파라미터 T(제너릭)를 클래스나 함수 안에서 사용하면 물음표가 없더라도 T는 널이 될 수 있다. 
```kotlin
fun main(){
    printHashCode("abc")
    printHashCode(null)
}

fun <T> printHashCode(t: T){
    println(t?.hashCode())
}
```

T가 널을 포함하지 않도록 설정하려면 타입 상한(upper bound)를 지정해야한다. 
널이 될 수는 타입을 상한으로 지정하면 널 값을 거부할 수 있다.
타입 상한을 지정하려면 <T : Any> 와 같은 방식을 사용한다.
```kotlin
fun <T:Any> printHashCode(t: T){
    println(t.hashCode())
}
```
타입 파라미터는 널이 될 수 있는 타입을 ? 없이 지정하는 유일한 예외이다.

### 널 가능성과 자바
자바 코드에서는 애노테이션으로 표시가능한 널 가능성 정보가 있다.
이런 정보가 코드에 있으면 코틀린도 그 정보를 활용한다.
자바의 @Nullable 은 코틀린에서 보면 String?과 같고, @NotNull 은 코틀린에서 보면 String과 같다.
코틀린은 여러가지 널 가능성 애노테이션을 참조한다. JSR-305표준 / 안드로이드 / 젯브레인스 도구들이 지원하는 애노테이션들이
코틀린이 이해하는 애노테이션이다. 

#### 플랫폼 타입
플랫폼 타입은 코틀린이 널 관련 정보를 알 수 없는 타입이다. 이는 널이 될 수 있는 타입으로 처리해도 되고 널이 될 수 없는 타입으로 처리해도 된다.
자바와 마찬가지로 플랫폼 타입에 대해 수행하는 연산에 대한 책임은 사용자에게 있다. 따라서 컴파일러는 모든 연산들 허용한다.

코틀린 컴파일러는 가시성이 공개인 함수의 notnull 타입 파라미터와 수신 객체에 널 검사를 추가한다.
따라서 공개 가기성 함수에 널 값을 사용하면 바로 예외가 발생한다.

이러한 값 검사는 함수 호출 시점에 이루어진다.
따라서 잘못된 인자로 함수를 호출해도 인자가 여기저기 전달되어 엉뚱한 위치에서 에러가 발생하는 것이아니라,
함수 호출 시점에 발생한다.

코틀린에서는 플랫폼 타입을 직접 선언할 수 없고, 자바 코드에서 가져온 타입만 플랫폼 타입이 될 수 있다.
따라서 IDE나 컴파일러 오류 메시지에서만 플랫폼 타입을 확인 할 수 있다.

이러한 표시는 TYPE! 으로 표시한다.(TYPE 뒤에 !가 붙는 형태)
이는 널 가능성에 대해 아무런 정보도 없다는 것을 의미한다.

#### 상속
코틀린에서 자바 메소드를 오버라이드 할 때 메소드의 파라미터와 반환타입을 널이 될 수 있는 타입으로 선언할지
널이 될 수 없는 타입으로 선언할지 결정해야 한다.

자바 클래스나 인터페이스를 코틀린에서 구현할 경우 널 가능성을 제대로 처리하는 일이 중요하다.
메소드를 다른 코틀린 코드가 호출할 수 있으므로 코틀린 컴파일러는 
널 불가능 파라미터에 대해 널이 아님을 검사하는 구문을 추가한다.

따라서 자바 코드가 그 메소드에 널 값을 넘기면 이 문장을 지나며 예외가 발생한다.
그 파라미터를 메소드 안에서 사용하지 않더라도 이 예외가 발생하게 된다.

## 정리
1. ?. / ?: / as? 연산자 사용 방법
2. !! (널 아님 단언)
3. 라이브러리 함수 let 을 사용한 코드 축약
4. 플랫폼 타입


