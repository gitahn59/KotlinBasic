# 코틀린의 원시 타입
코틀린은 원시 타입과 레퍼를 구분하지 않는다.

## 원시 타입
자바는 원시 타입과 참조 타입을 구분한다. 자바의 원시 타입은 변수에 그 값이 직접 삽입되지만, 참조 타입은 변수에 메모리상 주소가 들어간다.
반면 코틀린은 원시 타입과 래퍼 타입을 구분하지 않고 항상 같은 타입을 사용하다.

코틀린은 대부분의 경우 Int 타입을 int로 사용한다. 하지만 제네릭 클래스에 사용되는 경우 래퍼로 사용한다.
즉, 코틀린 컴파일러는 가능한 효율적으로 동작한다.

## 널이 될 수 있는 원시 타입 
자바에서는 null을 참조 타입에만 대입할 수 있기 때문에 널 가능 타입은 자바 원시 타입으로 표현할 수 없다.
따라서 컴파일러는 이를 래퍼로 사용한다.
 
## 숫자 변환
코틀린과 자바의 가장 큰 차이점중 하나는 숫자를 변환하는 방법이다.
코틀린은 숫자를 당른 타입의 숫자로 자동 변환하지 않는다.
원래 타입보다 결과 타입이 포함하는 숫자의 범위가 넓은 경우에도 자동 변환은 불가능하다.
ex) Int의 Long 타입으로의 변환

코틀린은 모든 원시 타입에 변환 함수를 제공한다.
변환 함수의 이름은 toByte(), toShort(), toChar() 등이다.
양방향으로 변환 함수가 제공되므로 서로 간의 변환이 모두 가능하다. 

## Any, Any?
자바에서는 Object가 모든 클래스의 조상이듯이, 코틀린에서는 Any 타입이 모든 타입의 조상이다.
특히, 코틀린에서는 원시 타입들의 조상이기도 하다.

## Unit : 코틀린의 void
코틀린의 Unit은 자바의 void와 동일한 기능을 한다.
즉 함수의 반환 타입이 없다면 Unit으로 설정하거나 return식이 없는 블록 함수를 사용한다.
Unit은 자바의 void와 달리 모든 기능을 갖는 일반적인 타입이다.
따라서 Unit을 타입 인자로 사용할 수 있다.
Unit은 단 1개의 값을 가지며 그 이름도 Unit이다. Unit 타입의 함수는 Unit 값을 묵시적으로 반환한다.

이러한 두가지 특성은 제네릭 파라미러를 반환하는 함수를 오버라이드 하면서 반환 타입을 없애고 싶을 때 유용하다. 

```kotlin
interface Processor<T>{
    fun process():T
}

class NoResultProcessor:Processor<Unit>{
    override fun process(): Unit { // 반환형이 Unit인 함수
        println("hello world") 
    }
}
```
 
## Nothing : 이 함수는 정상적으로 종료되지 않는다.
 
코틀린에서는 항상 성공적으로 값을 돌려주지 않는다. 
즉 반환 값이라는 개념 자체가 의미 없는 함수가 존재한다.
테스트 라이브러리들은 fail이라는 함수를 제공한다.
fail은 특별한 메시지가 들어있는 예외를 던져 현재 테스트를 실패시킨다.
또는 무한루프를 도는 함수도 값을 정상적으로 반환하지 않는다.

이러한 함수를 분석하는 경우 함수가 정상적으로 종료되지 않는다는 사실은 유용하게 사용된다.
이러한 경우를 코틀린에서는 Nothing 타입으로 표기한다.

Nothing 타입은 아무 값도 포함하지 않는다. Nothing은 함수의 반환 타입이나 반환 타입으로 쓰일 타입 파라미터로만 사용할 수 있다.

이러한 성질을 이용하여 코틀린 컴파일러는 특별한 기능을 제공한다.
?: 연산자와 Nothing을 사용하면 null 검사를 생략할 수 있다. 

```kotlin
fun main(){
    var str : String? = null 
    val rst : String = str ?: fail("str is null") // null 가능성이 있는 변수를 
    // null 불가능 변수에 대입해도 컴파일러가 오류를 뱉어내지 않는다
}

fun fail(message: String) : Nothing{
    throw IllegalStateException(message)
}
```
컴파일러는 함수의 반환형이 Nothing이므로 이후에 라인이 null 이면 진행되지 않음을 보장하므로
null 검사를 별도로 수행하지 않더라도 에러를 발생시키지 않는다.